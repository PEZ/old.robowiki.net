<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD><TITLE>Gwynfor - Robo Wiki -= Collecting Robocode Knowledge =-</TITLE>
<META NAME='KEYWORDS' CONTENT='Gwynfor'/>
<LINK REL="stylesheet" HREF="/robodocs/wiki.css">
</HEAD><BODY BGCOLOR="white">
<div class=wikiheader><h1><a href="robowiki@Robo_Home"><img src="/images/RoboWiki.png" alt="[Home]" border=0 align="right"></a><a href="robowiki@back=Gwynfor">Gwynfor</a></h1><a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<hr class=wikilineheader></div><div class=wikitext><H3>Gwynfor</H3>

by <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
<H4>What's special about it?</H4>

Well, not too much really. It's my first bot that will go public. Pretty boring... so far...
<p>
<H4>Great, I want to try it. Where can I download it?</H4>

You'll have to wait for a moment, as I've yet to release it, but it should be out there shortly... just as soon as this rewrite is done and ready.
<p>
<H4>How competitive is it?</H4>

Hard to say as it isn't in the <a href="robowiki@RoboRumble" class=wikipagelink>RoboRumble</a> yet, but it's first incarnation performs half-decent against mid-ranking bots, but gets slaughtered by the top bots. Hopefully the write will not be a regression.
<p>
<H4>How does it <a href="robowiki@Movement" class=wikipagelink>move</a>?</H4>

The first incarnation of Gwynfor used a <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a>-Flattener without <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a>. In the rewrite I eventually plan to replace this with real bullet-dodging <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a>, using flattening only when the enemy hitrate is high enough.
<p>
<H4>How does it fire?</H4>

Gwynfor's first version used a <a href="robowiki@VirtualGuns" class=wikipagelink>VirtualGuns</a> array of <a href="robowiki@CircularTargeting" class=wikipagelink>CircularTargeting</a> and <a href="robowiki@GuessFactorTargeting" class=wikipagelink>GuessFactorTargeting</a> with some inspiration from <a href="robowiki@AutomatedSegmentation" class=wikipagelink>AutomatedSegmentation</a>. In the rewrite, I'm going to first focus on a <a href="robowiki@Rednaxela/NeuralPatternMatching" class=wikipagelink>NeuralPatternMatcher</a> and see where that leads me
<p>
<H4>How does the <a href="robowiki@Melee" class=wikipagelink>melee</a> strategy differ from <a href="robowiki@OneOnOne" class=wikipagelink>one-on-one</a>  strategy?</H4>

Well, not at all. It can handle storing stats for multiple enemies and dealing with everything, but I'm suspecting it'll likely skip turns alot in that case, and certainly wouldn't perform well. I'm only developing for <a href="robowiki@OneOnOne" class=wikipagelink>one-on-one</a> so far.
<p>
<H4>How does it select a target to attack/avoid in <a href="robowiki@Melee" class=wikipagelink>melee</a>?</H4>

Targets the nearest known enemy. Not very smart, but again, not built for <a href="robowiki@Melee" class=wikipagelink>melee</a>, at least currently.
<p>
<H4>What does it save between rounds and matches?</H4>

It's first form saves all <a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a> data between rounds and matches. In the rewrite I plan to save the neural net weights between rounds but not between matches.
<p>
<H4>Where did you get the name?</H4>

Well, it's a Welsh name, which I felt represented my hopes for this bot sort-of. Kind of silly.
<p>
<H4>Can I use your code?</H4>

No, it's not released yet after all. After it's released, maybe.
<p>
<H4>What's next for your robot?</H4>

Get this rewrite off the ground, and then attempt the <a href="robowiki@PatternMatcherChallenge" class=wikipagelink>PatternMatcherChallenge</a> using my <a href="robowiki@Rednaxela/NeuralPatternMatching" class=wikipagelink>NeuralPatternMatcher</a> plan.
<p>
<H4>Does it have any <a href="robowiki@WhiteWhale" class=wikipagelink>WhiteWhale</a>s?</H4>

All the top bots? No real <a href="robowiki@WhiteWhale" class=wikipagelink>WhiteWhale</a>s yet, but I'm sure there will be some.
<p>
<H4>What other robot(s) is it based on?</H4>

The code architecture is somewhat inspired by my old Mervin robot (see <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>) but it's all new code.
<p>
<hr noshade class=wikiline size=1>
<H4>Comments, questions, feedback:</H4>

<p>
Just WRT your hitting walls problem, you do have <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> implemented, don't you? -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
Nope, haven't implemented <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a>, nor any other form of <a href="robowiki@WallAvoidance" class=wikipagelink>WallAvoidance</a> (i.e. limiting goal guess factors via <a href="robowiki@PrecisePrediction" class=wikipagelink>PrecisePrediction</a> that accounts for walls). I do have a form of <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> planned for the new movement method I'm working on. At some point I may add <a href="robowiki@PrecisePrediction" class=wikipagelink>PrecisePrediction</a> and/or <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> to my <a href="robowiki@WaveSurfing/GoToStyle" class=wikipagelink>goto style wavesufing</a>, but for the moment I see more potential in a new movement that I've just started coding. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
If you're doing a style of <a href="robowiki@WaveSurfing/GoToStyle" class=wikipagelink>goto wavesurfing</a>, it's fairly simple to 'warp' any points you are aiming at inside the field, so you don't hit the walls. But good luck for getting your wavesurfing working, and if my <a href="robowiki@Skilgannon/CodeSnippets" class=wikipagelink>'reachable' method</a> will come useful for you goto-surfing (it's what both <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a> and Stormrider use), feel free to use it. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
Thanks, I'll keep that in mind. First though I'm going to to experiment with a hybrid/combination of <a href="robowiki@AntiGravityMovement" class=wikipagelink>AntiGravity Movement</a> and <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>True Surfing</a> that I have some high hopes for. Hopefully this idea won't flop... :)
<p>
Hmm, after looking at more stuff on the wiki, I see a few have tried a combination of <a href="robowiki@AntiGravityMovement" class=wikipagelink>AntiGravityMovement</a> and <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a> before... however from what I see, everyone who's tried that combination before has failed to some extend or another. I wonder if this will be worth trying or not. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
Well... after some work I got my <a href="robowiki@AntiGravityMovement" class=wikipagelink>AntiGravityMovement</a> working, and wavesurfing (using "<a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>True Surfing</a>" which moves to local minima on the movement profile instead of the global minima). It seems to surf as intended, however: 1) This surfing style doesn't seem as effective, and 2) I'm not having much success making a "Gravity Source" to do effective wallsmoothing. In particular it seems to get stuck in the corners where it's close to two walls at once. If anyone has any tips they're welcome of course. In the meantime I'll probably leave this code and go back to working the   <a href="robowiki@WaveSurfing/GoToStyle" class=wikipagelink>goto wavesurfing</a> -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<UL >
<li>I found that vector sum based movement didn't play well with the precision demands of surfing.  Some of my movement styles are flagged as 'exclusive', and while using them I apply no other influences from walls, other robots, etc.  I expect that there are ways to make them cooperate, but for now I don't.  -- Martin
<li>Yes, this is rather consistant with the issues I was seeing. For one, I was using a seperate "guess factor force" for each enemy wave, weighting closer waves higher, but even with the weighting, the summation of which way it wants to go for the total of the waves, often produced more danger than just considering the waves one at time (closest only) even. Currently, I'm quite unsure of what kind of movement I want to go for (i.e. <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>True Surfing</a>, <a href="robowiki@WaveSurfing/GoToStyle" class=wikipagelink>GoTo Surfing</a>) but hopefully I can come to some kind of conclusion soon. Or better yet, a unique and effective idea if I'm lucky. Very lucky... -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<li> Unless you are precise-predicting a final point, it is definitly better to weight later waves on an inverse-exponential function, for example pow(0.7,time-until-wave-arrival). If you plot the function you'll see that the later waves are hardly weighted at all. Even once you have precise-prediction it is still better to weight later waves much lower, simple because so many things can change before the later waves arrive (new waves fired, enemy orbited more to one side, stats changed, etc). -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<li> Yeah, I think most of us weight the non-closest waves pretty lightly. I weight them by (1/time-to-impact) or (1/square(time-to-impact)) (that one's most common, I think), though I can't remember now how I concluded when to do which... Still, if even 1 in 100 situations makes two movement options seem almost exactly equal based on just the first wave, using the data for the second wave to break the tie is a very good idea. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<li> Ahh yeah, that sort of weighting is probably good. I was using 1/time-to-impact though in my <a href="robowiki@AntiGravityMovement" class=wikipagelink>AntiGravityMovement</a>/<a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a>  method though, and it didn't seem to do too great. Even if I removed my broken-wall-smoothing forces (which caused it to get stuck in corners), it still worked far worse than my "closest-wave-only-goto-surfing-that-ignores-what-is/isn't-reachable-and-ignores-walls-and-bumps-into-them". Perhaps alot of the problem with my "<a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>True Surfing</a>" though was that I wasn't accounting for the robot width, which caused it to stick around at local minimums in my movement profile that weren't particularly safe? I'm not sure if "<a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>True Surfing</a>" can be brought to the same performance as <a href="robowiki@WaveSurfing/GoToStyle" class=wikipagelink>GoTo Surfing</a>, but I may be wrong. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<UL >
<li> "True Surfing", as done by <a href="robowiki@RaikoMX" class=wikipagelink>RaikoMX</a>, <a href="robowiki@CassiusClay" class=wikipagelink>CassiusClay</a>, <a href="robowiki@Dookious" class=wikipagelink>Dookious</a> etc. will not get stuck in local minima. Every tick they see how far forward they could get before the wave hits them, how far backwards, and where they would be if they hit the brakes, and decide which is the least dangerous. Then they move forward, backwards, or stop. This is <a href="robowiki@TrueSurfing" class=wikipagelink>TrueSurfing</a>. GotoSurfing<a href="robowiki@action=edit&id=GotoSurfing" class=wikipageedit>?</a> is where you generate a list of points along the entire reachable guessfactor range, and go to the one you decide to be safest. Both require some form of <a href="robowiki@PrecisePrediction" class=wikipagelink>PrecisePrediction</a>. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
</UL>
<li> I don't think <a href="robowiki@TrueSurfing" class=wikipagelink>TrueSurfing</a> or GoTo<a href="robowiki@action=edit&id=GoTo" class=wikipageedit>?</a> Surfing are that different. The important thing is to have it bug-free and very precise. Most top bots use an algorithm that I would consider <a href="robowiki@TrueSurfing" class=wikipagelink>TrueSurfing</a> (<a href="robowiki@Dookious" class=wikipagelink>Dookious</a>, <a href="robowiki@CassiusClay" class=wikipagelink>CassiusClay</a>), while <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a> has recently got up to #3 with a GoTo<a href="robowiki@action=edit&id=GoTo" class=wikipageedit>?</a> surfing. <em>(Edit: See <a href="robowiki@CassiusClay/Butterfly" class=wikipagelink>CassiusClay/Butterfly</a> or <a href="robowiki@Dookious/DookiSailer" class=wikipagelink>Dookious/DookiSailer</a> for details on the algorithms, if you wish.)</em> -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<li> Hmm,  I think I misinterpreted the definition of <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a> as stated on it's page, to mean only considering the points one tick ahead and directly behind the robot, which would indeed get stuck in local minima. So if I understand "True Surfing" correctly now, it only evaluates the guessfactors at the end destinations, of going fully forward, fully breaking, and fully reverse and not anywhere inbetween? One other question I have is, when surfing multiple waves (with either <a href="robowiki@TrueSurfing" class=wikipagelink>TrueSurfing</a> or GoToSurfing<a href="robowiki@action=edit&id=GoToSurfing" class=wikipageedit>?</a>), how do people tend to decide what point to orbit? Do most people tend to orbit the origin of the nearest wave, or the weighted average of the origins of all the waves or something else or does it not matter too much? -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<UL >
<li> It probably doesn't matter too much. I've heard of versions of CC that mistakenly orbited the enemy's current location and didn't lose rating points. Anyway, I think most orbit closest wave, but correctly take into account the waves' different origins when calculating <a href="robowiki@GuessFactors" class=wikipagelink>GuessFactors</a> on each wave. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<UL >
<li> Ahh, I see. Thanks. I think I'll give it a try making my own <a href="robowiki@TrueSurfing" class=wikipagelink>TrueSurfing</a> implementation now, and try out orbiting the average origin of the enemy waves with the same weighting as it uses for the guessfactors. I think using that might give a subtlety smoother movement. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<UL >
<li> I found a weighted one (weighted towards the nearest bullet) based on the waves distance to your robot worked well, but it also ate alot of extra cpu clocks. --<a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
</UL>
</UL>
</UL>
</UL>
<p>
Okay! I finally got a working <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a> implementation made from scratch (well, with a little code reuse from my old <a href="robowiki@CircularTargeting" class=wikipagelink>CircularTargeting</a> code to do the precise prediction)! And damn... this thing is creating a <em>really</em> flat movement profile according to my builtin profile monitor (Well, a compliment to <a href="robowiki@Voidious" class=wikipagelink>Voidious</a> though: I've yet to see a flatter profile than <a href="robowiki@Dookious" class=wikipagelink>Dookious</a>'s profile). I'm quite proud of my predictor code, which is a little sluggish, but fully accounts for everything except for robot-robot collisions (yes, it does include accurate turning speed limits). I haven't implemented <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> yet, so it's performance is still not so great though. Actually, against Shadow anyways, it wins a couple matches out of 35, but in a majority of the cases where it loses, it's either a close match where it just can't win (my lack of energy management could be alot of the issue) or getting stuck in a corner. It's encouraging that matches against Shadow end up fairly close when I don't get stuck in a corner, even if I very rarely win in those "close" situations. Thanks alot to everyone who's given tips! Next stop? <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a>!
<p>
Hmm, One thing I haven't seen much on, is what to do after the enemy has fired a first shot, but my movement profile is flat so far. In the "GoTo<a href="robowiki@action=edit&id=GoTo" class=wikipageedit>?</a> Surfing" I'd select a random guessfactor to go for, but as <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a> doesn't use "goal guessfactors" in the same way, I suppose any sort of randomized perpendicular movement that doesn't run into walls would do the job fine? One other thought I've had is, do people usually save their own movement profile between rounds? Currently I don't, but I ponder if it might help, at least to avoid the points it visits early in the round from being as predictable. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
Interesting... I just added some energy management code which roughly means: 1) Don't fire more powerful bullets than needed to kill it, and 2) Avoid firing bullets that would use more than 10% of our energy left. The effect of this, was a drastic drop in score against <a href="robowiki@Shadow" class=wikipagelink>Shadow</a> but a drastic increase in scorn against <a href="robowiki@Duelist" class=wikipagelink>Duelist</a>. I wonder what the right balance is or if there is an effective way method to manage energy against both bots... -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
My suggestion: don't test against Shadow unless you are a) just about to beat him anyways and b) are worried about your <a href="robowiki@PremierLeague" class=wikipagelink>PremierLeague</a> score. Not beating Shadow is nothing to worry about, nothing beats the strongest version of Shadow anyways =). <a href="robowiki@RaikoMicro" class=wikipagelink>RaikoMicro</a> is one of my favourite testbots =) -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
But even so, this has shown me that the optimal level of energy conservation depends on the particular enemy, and thus ideally I'd have some way to adjust this. Some thought/observations about this I've had, is that:
<UL >
<li>If hit rate is <strong>very</strong> high, it's optimal to use powerful bullets to finish it quick.
<li>If the hit rate is <strong>very</strong> low it's optimal to use powerful bullets in hopes of lucky hits getting a win.
<li>If the hit rate is somewhere in the middle, it's optimal to make some efforts to to conserve energy somewhat.
</UL>
I just wonder what the best way to decide a level of energy conservation is, and what the best factors of it to adjust are. Oh, and yes, <a href="robowiki@RaikoMicro" class=wikipagelink>RaikoMicro</a> seems like a good test bot, except I'm annoyed at how I can't yet beat it. :-) -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
IMO, the optimal bullet-power algorithm works like this: if the distance is less than 150 or the hitrate is more than 33%, fire 3 power bullets. Otherwise fire 2 or 1.9 power bullets. Don't fire a bullet that would do more damage than the enemy has life, and would gain if one of their bullets in the air hit you. If you are low on energy fire smaller bullets, eg. energy/10 or energy/16, and never fire a bullet if it would disable you. Remember that the minimum bullet power you can fire is 0.1 =). Some parts of this I still need to add to <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a>. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
That sounds like overall a good algorithm, however I'm not sure if accounts for the underlying mechanic allowed me to get dramatically better results against Shadow without energy management. I'm not sure of the exact hit rate I was getting there, but I highly doubt it was over 33% -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
---
<p>
I seem to be having alot of issues with getting movement right. For quick tests, I've tried plugging in various <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> code snippits that I've seen on the wiki, but they often seem to get my bot stuck even more, and if they don't they still cause a large drop in my score even though the movement may look fine to my eye. Anyone have some general tips for movement development? Would it be worthwhile to work in the context of <a href="robowiki@MovementChallenge2K7" class=wikipagelink>MovementChallenge2K7</a> in order to develop movement while being sure the gun isn't getting in the way?
<p>
Yeah, working against something solid is a good way to go. Do you have any graphical debugging? It can help a lot for working out the finer details of the trig. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
Currently, I use alot of debugging graphics in my targeting (i.e. a pretty display of the opponent's movement profile and as well as showing which gun is the active one of my virtualguns array), and also display a pretty graph of my own movement profile, however don't currently have any debugging graphics for my movement itself. Also, I just read more about <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a> and found that apparently <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a> is actually generally more about avoiding where you've been hit before. My implementation just was about avoiding anywhere I've been before. I think my movement therefore counted more as a "Flattener Surfing" of sorts (Haha, explains why I saw such a darn flat curve before). I'm thinking of making it bias against place where it's been hit before, anyone have any tips from experience about how heavily/lightly the flattener should be weighted compared to where I've been hit before?-- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
In general, you shouldn't need any 'flattening'. Pure hit-dodging is good enough. I only recently (last week) added flattening to <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a>, and it only gave me a 5 point boost. You have to be careful about flattening against simple targeting bots, because if you do hit-surfing you should be able to 'learn' their gun and dodge it perfectly, but if you add 'flattening' you will only make their hitrate drop to that of a random-targeting gun. <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a> only enables its flattener if the enemy hitrate is above 10%, and even then it only gets weighted 50/50 with the hit-surfing buffers. I know Dookious, Phoenix and Shadow all employ similar methods. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<UL >
<li> Hm, true enough. Since I still want to track my movement profile for display, and I already have flattening coded, I'll keep it around, add hit-dodging, and use something like that hitrate threshold to decide if it should use the flattener or not. Thanks. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
</UL>
<p>
(edit conflict) First, you should consider what your tank's goal is: winning battles (premier league) or winning them absurdly (roborumble).  A flat movement works best against strong guns, but it will not be as good as it could be against weak guns.  As I have neither, I am not speaking from experience. -- Martin
<UL >
<li> My goal? As much of both as I can get of course I'll probably use something like hitrate as <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a> noted to decide if the flattener is needed. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<li> As I read your goal is to get into <a href="robowiki@The2000Club" class=wikipagelink>The2000Club</a>, the only thing you need is a <strong>flawless</strong> straightforward implementation of any kind of surfing. That should give you a 90+ score against the vast majority in the rumble, propelling you (close) to a 2000 rating. Nevermind those around 50 excellent targetters, they won't bring you down much. And when you have accomplished your goal, you will have lots of room for improvements. Welcome by the way, seems you are really doing your homework.   -- <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
<li> Thanks. Hopefully switching from a <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a>-Flattener to a <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a>-Dodger (with optional flattening against stronger opponents) will improve things a bit. It shouldn't be hard to get that implemented as that isn't far from what I already do for the <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a>-Flattener. What I'm most worried about right nowChanges is getting a robust <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> working, but I'm sure I'll get that working sooner or later. Thanks for the welcome, and I'm trying a bit even if I'm occasionally misinterpreting some things at first :-) -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
</UL>
<p>
Interesting... before starting code to match onHitByBullet<a href="robowiki@action=edit&id=HitByBullet" class=wikipageedit>?</a> events to known waves, I noticed I haven't constructed my <a href="robowiki@EnemyWaves" class=wikipagelink>EnemyWaves</a> correctly, and they lagged two turns behind the real bullets and were not firing from the exact correct location (I found details about this offset around the wiki). So after fixing this, I thought "heck, it'll be interesting" so I did another test with my <a href="robowiki@WaveSurfing/TrueSurf" class=wikipagelink>TrueSurfing</a>-Flattener vs. Shadow to see the effect this had. The end result, was that whenever I wasn't stuck in a corner, I was actually getting an extremely similar hitrate against Shadow than Shadow was getting against me. It's rather fun watching Gwynfor and Shadow both missing eachother a lot, but Shadow being down to 0.0 energy while I still had 16.0 or so (sad thing is, it made a comeback and I didn't have it dead again till at 5.3 energy). I'd call that test encouraging that my <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a>-Flattener is pretty good besides the lack of <a href="robowiki@WallSmoothing" class=wikipagelink>WallSmoothing</a> and that my targeting isn't 100% useless... :-)
Anyways, back to matching onHitByBullet<a href="robowiki@action=edit&id=HitByBullet" class=wikipageedit>?</a> to <a href="robowiki@EnemyWaves" class=wikipagelink>EnemyWaves</a> now, so I can do <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a>-Dodging properly against people who don't target as well as the top bots '(edit: Okay, well, it seems getting that great hitrate ratios only happens every so often. It seems however, that sometimes Shadow gets a series of consecutive hits on me, but other times I'm just dodging perfectly. I'm not certain, but I think this likely means that sometimes Shadow is able to sometimes find some predictability in my flattening but other times it's just clueless. Still, the fact that it's able to fool Shadow fairly often isn't a bad thing. Anyways, back to concentrating on making movement that's good for thrashing non-top bots.)' -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
While working on getting <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a>-Dodging coded more, I casually did a codesize check for the heck of it. Sure, for a <a href="robowiki@MegaBot" class=wikipagelink>MegaBot</a>, codesize is meaningless, and I do have some "historic" classes of unused movement/targeting methods around, but even so... 14412 codesize. This one is getting big ;-) -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<UL >
<li>My bot is 37586 in a test compile tonight.  /shrug -- Martin
<UL >
<li> Haha, nice. But yeah, issues of messiness in my code worry me more than my codesize :-) -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
</UL>
<li>What about 158026 codesize? :D --<a href="robowiki@Krabb" class=wikipagelink>Krabb</a>
</UL>
<hr noshade class=wikiline size=1>
<p>
Well, code rot has been kind of ill-managed here as I've developed Gwynfor. Now I need to decide, if I want to remake Gwynfor largely from scratch, do a lengthy refactoring, or hackishly finish off <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a> before moving on. It's a pity because I put a lot into it. Hopefully lessons learned will make the next attempt smoother. If I remake from scratch, or move on after finishing off <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a>, I wonder what I'll call my new bot, if it will still go by the name Gwynfor, use a variation like GwynforII<a href="robowiki@action=edit&id=GwynforII" class=wikipageedit>?</a>, or if I'll choose a new name entirely. Decisions, decisions... Curse you code rot... -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
<UL >
<li> I let <a href="robowiki@Dookious" class=wikipagelink>Dookious</a> go a long time before a full rewrite (it was already 2100+). With Robocode's addictive properties, it's easy to fall into a trap of writing messy code, for me anyways. I'm not sure if I can give advice on <em>when</em> is the best time to do it, but I can say that I was a very, very happy camper afterwards. I went from ~36k <a href="robowiki@CodeSize" class=wikipagelink>CodeSize</a> to just over 20k (not that I made it a goal), I could once again be proud of my code (and not just my rating), and I even ended up gaining a few rating points. Plus it's so much more enjoyable to work with the code and easier to add new features. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
<p>
<UL >
<li> <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a> is in need of a major re-write as well... -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
</UL>
<p>
Okay, in the rewrite, one issue I'm pondering, is how to set up robust event handling. In Gwynfor's first incarnation, I didn't really deal with many events besides onStatus, on<a href="robowiki@ScannedRobot" class=wikipagelink>ScannedRobot</a> and onPaint, however in order to do really nice surfing I'll have to deal with the different bullet events and such things. The issue is, I'm pondering a robust way to handle events in a way that keeps the state of the robot while it's processing a tick completely atomic (i.e. all events are buffered until the next time around the main loop). In Gwynfor's first form, It wasn't hard to make my "EnemyRobot<a href="robowiki@action=edit&id=EnemyRobot" class=wikipageedit>?</a>" data storage class buffer scannedRobotEvent<a href="robowiki@action=edit&id=RobotEvent" class=wikipageedit>?</a> objects, and also make my "BattleState<a href="robowiki@action=edit&id=BattleState" class=wikipageedit>?</a>" data store the next pending statusEvent, and such things. I'm just wondering what have other people tended to do to address this type of issue? I haven't seen much on the wiki about handling this. I'm thinking of storing a list of all events that occurred on a tick, and letting various data storage classes rummage through the list themselves, but I'm not sure if this is a great way to deal with it. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<UL >
<li>I have a heirarchy like this: 'Ugluk' extends 'Foundation' extends 'EventHandlerBase' extends robocode.TeamRobot.  In EventHandlerBase the only event handlers I have are 'OnStatusEvent', 'OnSkippedTurnEvent', 'OnWin', and 'OnDeath'.  In 'OnStatusEvent' (and only then) I first update my general state data, and then I collect all other events available as Vectors (e.g. super.getScannedRobotEvents() ), translate the events into custom data formats, and then process them in Foundation via abstract methods.  You will not receive a StatusEvent following a DeathEvent, but you will with the other two.  After processing the StatusEvent, control returns to my bot (after super.execute() in my run() loop) and my bot acts on all of the updated data. -- <a href="robowiki@Martin_Alan_Pedersen" class=wikipagelink>Martin</a>
</UL>
</div><hr class=wikilinefooter>
<div class=wikifooter><form method="post" action="robowiki" enctype="application/x-www-form-urlencoded">
<a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<a href="robowiki@action=edit&id=Gwynfor" class=wikipageedit>Edit text of this page</a> | <a href="robowiki@action=history&id=Gwynfor">View other revisions</a><br>Last edited February 11, 2008 16:56 EST by <a href="robowiki@Rednaxela" title="ID 13309 from enc0104.engg.ucalgary.ca">Rednaxela</a> <a href="robowiki@action=browse&diff=1&id=Gwynfor">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /></form></div>
</body>
</html>