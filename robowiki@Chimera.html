<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD><TITLE>Chimera - Robo Wiki -= Collecting Robocode Knowledge =-</TITLE>
<META NAME='KEYWORDS' CONTENT='Chimera'/>
<LINK REL="stylesheet" HREF="/robodocs/wiki.css">
</HEAD><BODY BGCOLOR="white">
<div class=wikiheader><h1><a href="robowiki@Robo_Home"><img src="/images/RoboWiki.png" alt="[Home]" border=0 align="right"></a><a href="robowiki@back=Chimera">Chimera</a></h1><a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<hr class=wikilineheader></div><div class=wikitext><H4>Bot Name</H4>
 
Chimera
<p>
<H4>Version History</H4>
 
1.2 Fixed wave evaluation bug that caused all bullets to be registered as hits, added ability to save/retrieve data files on enemies.<br>
1.1 Finished the GF/VG array which actually wasn't working at all... and I forgot. Also features several movement tweaks, specifically <a href="robowiki@AntiGravity" class=wikipagelink>AntiGravity</a> is no longer broken and doesn't get stuck against the walls as often.<br>
1.0 Original Release, lacks bullet dodging, needs tweaking.
<p>
<H4>Author</H4>
 
<a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
<H4>Extends</H4>

<a href="robowiki@TeamRobot" class=wikipagelink>TeamRobot</a>
<p>
<H4>What's special about it?</H4>

The Chimera is a mythical beast that is the combination of several other beasts. Like the mythical Chimera, this one is the combination of several different movement and targeting techniques that are all used at once instead of choosing from the best.
<p>
When I was first starting to plan what my bot would be all about I remembered reading in some of the <a href="robowiki@Strategy" class=wikipagelink>Strategy</a> sub-pages that as we start out, we should try everything. This bot does just that. All in one big mess.
<p>
<H4>Great, I want to try it. Where can I download it?</H4>

<a rel="nofollow" href="https://www.robocoderepository.com/BotDetail.jsp@id=3276">https://www.robocoderepository.com/BotDetail.jsp?id=3276</a>
<p>
<H4>How competitive is it?</H4>

I'm not too sure yet, It still needs to participate in the rumble a bit longer for my satisfaction. However, it's floating around a ranking of 81 (with a momentum of 4) as of 04.29.07 and I don't think that's half bad, all things considered. Personally I'm suprised it does so well with it's crippled movement, perhaps the way it dynamically changes it's movement helps keep it from completely breaking down.
<p>
<H4>How does it <a href="robowiki@Movement" class=wikipagelink>move</a>?</H4>

It uses several movement strategies:
<UL >
<li><a href="robowiki@AntiGravity" class=wikipagelink>AntiGravity</a>
<li>Oscilation
<li>Random GoTo<a href="robowiki@action=edit&id=GoTo" class=wikipageedit>?</a>
<li>Random Corner
</UL>
<p>
It uses all of these at once moving to the weighted average location of all of them. The weight of each method is based off a simple reward/punishment scheme such that it gives the most effective strategies the highest weight. The other strategies give a highly variable quality to it's movement. It's interesting to watch simply because it's movement is highly organic. It's not the best and definitely needs some tweaking but it's getting there. Mostly the biggest problem now is that ALL of it's movement strategies are somewhat broken. I'm amazed that it's not crippled.
<p>
<H4>How does it fire?</H4>

It uses several targeting methods:
<UL >
<li><a href="robowiki@HeadOnTargeting" class=wikipagelink>HeadOnTargeting</a>
<li><a href="robowiki@StasticalSymbolicPatternMatching" class=wikipagelink>StasticalSymbolicPatternMatching</a>
<li><a href="robowiki@CircularTargeting" class=wikipagelink>CircularTargeting</a>
<li><a href="robowiki@RandomTargeting" class=wikipagelink>RandomTargeting</a>
<li><a href="robowiki@GuessFactorTargeting" class=wikipagelink>GuessFactorTargeting</a>
</UL>
<p>
Like the movement it uses these methods all at once finding the weighted average location of all of them. I think the pattern matcher is my best targeting method so far. The accuracy might actually improve if I made it only use this one method, but I wanted to make a bot that used everything, so I had to stick by my guns (pun intended).
<p>
<H4>How does it <a href="robowiki@DodgingBullets" class=wikipagelink>dodge bullets</a>?</H4>

It just has crazy movement. I will eventually add in a wave surfing bullet dodging strategy.
<p>
<H4>How does the <a href="robowiki@Melee" class=wikipagelink>melee</a> strategy differ from <a href="robowiki@OneOnOne" class=wikipagelink>one-on-one</a>  strategy?</H4>

The only difference is the radar lock. In Melee it will rotate it's radar when it's gun is hot, in OnOnOne<a href="robowiki@action=edit&id=OnOnOne" class=wikipageedit>?</a>, it will lock the radar on the enemy bot.
<p>
<H4>How does it select a target to attack/avoid in <a href="robowiki@Melee" class=wikipagelink>melee</a>?</H4>

<UL >
<li>Target Choice Hierarchy:
<UL >
<li>First it employs a complex rating system to find the bots that are the least of a threat to it. Targeting the weakest. The result is that the Chimera feeds off of the weaker bots to build its health so it can take on opponents stronger than itself. This is how it can manage to beat Nimrod in a melee situation where all other bots are sample bots.
<li>If there is a particular angle slice that has a dense bot population, it will target the bot closest to the center of that slice. Somewhat like <a href="robowiki@AreaTargeting" class=wikipagelink>AreaTargeting</a>. Of course the idea here is to shoot in a direction where, if it misses it's target, it could still hit someone else.
<li>If a bot is particularly low on health it will target them, hoping to get the kill before the other bots.
<li>if a bot is particularly close, it will target them.
</UL>
</UL>
<p>
<UL >
<li>Bots to avoid:
<UL >
<li>Bots that move straight towards it (ie: rammers).
<li>Bots that have killed it more than it has killed them.
<li>Bots with particularly high health in comparison to it's own.
</UL>
</UL>
<p>
<H4>What does it save between rounds and matches?</H4>

It saves it's symbolic PatternBuffer<a href="robowiki@action=edit&id=PatternBuffer" class=wikipageedit>?</a>, guess factors, targeting strategy effectiveness, and some stats on each bot (so it can better pick it's targets). It does not save anything between matches... although I may eventually add such a feature.
<p>
<H4>Where did you get the name?</H4>

Mythology, see: <a rel="nofollow" href="https://en.wikipedia.org/wiki/Chimera">https://en.wikipedia.org/wiki/Chimera</a>
<p>
<H4>Can I use your code?</H4>

Sure, but it is horridly messy. I don't know much about this stuff yet so it's all in one big messy class file.
<p>
<H4>What's next for your robot?</H4>

<UL >
<li>AntiWaveSurfer<a href="robowiki@action=edit&id=AntiWaveSurfer" class=wikipageedit>?</a> Targeting
<li>Change in relative angle PM Targeting
<li>A more Highly segmented GF Targeting system (distance,latV,NearWall<a href="robowiki@action=edit&id=NearWall" class=wikipageedit>?</a>,RelativeEnergy<a href="robowiki@action=edit&id=RelativeEnergy" class=wikipageedit>?</a>,etc...)
<UL >
<li>I want to figure out how to make this GF gun replace my current one by having it capable of using both vague and distinct data. In effect it needs to still be accurate if there's not enough information gathered and it needs to be able to determine the significance of each segment as it pertains to each individual bot. If I can't get that to work, then my only other option is to just make multiple GF guns segmented on that data and have the current targeting system evaluate the accuracy of each one individually. Actually, that might work pretty well.
</UL>
<li>Self future position prediction for targeting purposes (because bots whose movement is based on their targets will not lend well to absolute position PM targeting).
<li><a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a> Movement
<li>BulletDodging<a href="robowiki@action=edit&id=BulletDodging" class=wikipageedit>?</a> (Dodge the bullets of other team mates in a team situation).
<li>Bullet sheilding (I've got this idea, that if I just shoot three very low power bullets directly at the source of an enemy wave right before it crashes over me, that I may not have to dodge bullets as well).
<li>Long-Term bot memory
</UL>
<p>
<H4>Does it have any <a href="robowiki@WhiteWhale" class=wikipagelink>WhiteWhale</a>s?</H4>

In my testing, I used <a href="robowiki@Nimrod" class=wikipagelink>Nimrod</a> as my main goal to beat. I can fight about evenly OnOnOne<a href="robowiki@action=edit&id=OnOnOne" class=wikipageedit>?</a> with him and beat him in a melee situation (where all the other bots are sample bots). Other than that, every other somewhat competitive bot is a WhiteWale<a href="robowiki@action=edit&id=WhiteWale" class=wikipageedit>?</a>. I've still got quite a bit of tweaking left to do on this bad mamajama.
<p>
<H4>What other robot(s) is it based on?</H4>

A lot of my code is based on AntiGravityBot<a href="robowiki@action=edit&id=AntiGravityBot" class=wikipageedit>?</a>. I actually use the gravitational strategy to find the weighted averages for my movement and targeting systems. I used <a href="robowiki@DrawingBot" class=wikipagelink>DrawingBot</a> just to help me out with debugging. There are several other bots that I've gotten inspiration from such as: <a href="robowiki@FunkyChicken" class=wikipagelink>FunkyChicken</a>, <a href="robowiki@FloodMini" class=wikipagelink>FloodMini</a>, <a href="robowiki@SpareParts" class=wikipagelink>SpareParts</a>, <a href="robowiki@WeeklongObsession" class=wikipagelink>WeeklongObsession</a>, and <a href="robowiki@Dookius" class=wikipagelink>Dookius</a> to name a few.
<p>
<hr noshade class=wikiline size=1>
<H4>Comments, questions, feedback:</H4>

<p>
<i>This little piece started from <a href="robowiki@StasticalSymbolicPatternMatching" class=wikipagelink>StasticalSymbolicPatternMatching</a> that quickly got off topic.</i>
<p>
That's not a bad idea. It may be possible to create different movement profiles such that certain movement types (that do not lend well to pattern matching) can be plugged in. For instance, one could create an anti-antigrav targeting system where the bot takes a simplified antigrav system including the most commonly used variables for attraction/repulsion and as the bot observes its movement, it figures out what those variables are. The only issue I see with all of this, is that random movement will still be an issue because the bot won't generate the same random variables as his target. I certainly will take a look at your bot. If <a href="robowiki@SingleTick" class=wikipagelink>SingleTick</a> got me this far, I can only imagine what I can learn from the tuned version. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
Oh, no, I caused a little confusion there.  The Anti-xxx is *my* movement system.  So you plug in the enemy's gun &amp; avoid it (and therefore kick the crap out of it).  Plugging in the enemy's movement is a *far* more difficult task, because you'd have to simulate all the variables the enemy takes into account for every tick until your bullet hits, including your own movement.  That's why I said it was off topic ... -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
Ah, I see. Targeting is a precise function of a bot's movement whereas a bot's movement is a fuzzy function of several variables. Essentially you're still talking about targeting but it's virtual guns for you enemies targeting you. If that's the case it may be possible to include targeting "definitions" and avoid bullets based on what definitions the enemy is following. They would have to be evaluated based on the same way my GF gun determines accuracy of its virtual guns. You're suggesting to impliment special virtual guns for bots of xxx name. Wouldn't a really good wave surfer be able to accomplish the same thing? Although... not as easily or as accurately against those certain bots. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
Wave surfers do that very well against head-on &amp; linear targeting as well as GF guns, but they can't predict PM guns very well.  Be careful, you can't evaluate the enemy's VGs the same way you do your own.  The only times you know where he shot are when you are hit or onBulletHitBullet<a href="robowiki@action=edit&id=BulletHitBullet" class=wikipageedit>?</a>.  Then you can evaluate your definition to see if he's following any of them.  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
Wouldn't it be simplier to adjust your own targeting techniques (in a massive VG array) so that you can use the same functions to target your enemy or calculate how your enemy targets you? Essentially VG array uses the majority of targeting techniques. It should be able to find the most accurate method being used and surf around them. The location of the bullet could be based on the most likely bullet trajectory and the distance that the bot revolves around the bullet would be based on the distance the second/third most likely angles are from the most likely. This should ensure that the three most likely angles are avoided. Again though, you could still plug your problem bots' gun code into the array, use it yourself against other bots, and avoid it almost every time when they use it. I'm definitely going to have to figure out bullet dodging and minimum risk movement. I think that's all my bot is lacking at the moment. It's going to take quite a bit of work to recode my guns to work both ways... but it will definitely be worth it. Super-duper-wave-surfing Here I come! -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
You could certainly simulate enemy targeting algorithms, try and figure out which one is closest to what he's doing, and surf the angles generated by your simulated algorithms. (I think I actually made a poor attempt at this long before Dookious was a contender.) However, I'd say it's <em>extremely</em> likely that you will get much, much better results with the traditional method of surfing, in which you are dodging what angles the enemy is aiming at (updated when he hits you) in different situations. In a way, it's almost like a more abstract way of doing exactly the kind of thing you're talking about.
<p>
There is also <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a>, in which you also (or instead) update your stats when you don't get hit, to simulate the enemy's learning process and randomize your movement even when you're not getting hit. Many expert movers turn on <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a> if they are getting hit a lot, but it can really blow your scores against lesser bots, since you're kind of "corrupting" your dodging stats. (Way off topic now, maybe we should cut/paste this discussion elsewhere. =))
<p>
-- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
Cut and pasted. You're right, that was getting unruly. I figured since I don't have my own subpage for movement (and I can't think of a reason why I would need one), I figured I'd just move the movement discussion here. 
<p>
In any case, I see what you're saying. I've got to make my bot be able to dodge bullets fired by both smart and stupid bots. The only bots that curve flattening seemed like an obvious defense against was those that used AntiWaveSurfing<a href="robowiki@action=edit&id=AntiWaveSurfing" class=wikipageedit>?</a> targeting. Obviously these bots essentially have GF and inverse GF targeting strategies. The idea behind <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a> seemed to be to keep such bots guessing. In other words, you're suggesting that CurveFlatening<a href="robowiki@action=edit&id=CurveFlatening" class=wikipageedit>?</a> be another movement mode to incorporate. If that's the case, then it is certainly crucial that I figure out a way to discover the best movement profile weights based on all the bots combined as well as the current target and the bots that are targeting me. The number of beasts to add to the <a href="robowiki@Chimera" class=wikipagelink>Chimera</a> is increasing... as is their complexity. I was lucky to get this far. Seems as if my aspirations are soon turning into a to-do-list. @.@ -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
If you'd like to see an example of using the same code for tracking for your own VGs as well as tracking your enemy's, I will again point you to <a href="robowiki@LifelongObsession" class=wikipagelink>LifelongObsession</a> (if you can plug your enemy's code, you should be able to plug your own, right?  actually, you just create another instance of the same class).  When I combined that technique into my own wave surfing, it only helped a very little bit in the rumble.  BUT, I still think there is potential.  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
Actually, I'd kind of look at it the opposite way - <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a> could be useful against any learning gun. Theoretically, if your movement and their gun were segmented exactly the same, you could never get hit if you just had <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a> stats. With regular surfing against a non-learning gun (say, <a href="robowiki@LinearTargeting" class=wikipagelink>LinearTargeting</a> or <a href="robowiki@HOT" class=wikipagelink>HOT</a>), once you learn the angle the enemy shoots at in a situation, you will dodge it forever; against a long-term learning gun, you will dodge them for a long time; against a fast learning (<a href="robowiki@AntiSurfer" class=wikipagelink>AntiSurfer</a>, basically) gun, they will quickly adapt and start hitting you again unless you try and stay ahead of them with <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a>.
<p>
As it turns out, at least in my experience, you're far better off just having quick adapting surfing against the great majority of tanks, even most with learning guns. If your surfing is correctly figuring out where it's safe to be, adding in <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a> will juts put you back in harm's way. But against a top notch gun, it can often make a huge difference - I've had versions of <a href="robowiki@Dookious" class=wikipagelink>Dookious</a> that would get 54% against <a href="robowiki@Ascendant" class=wikipagelink>Ascendant</a> with normal movement, but 66% if I hard-coded <a href="robowiki@CurveFlattening" class=wikipagelink>CurveFlattening</a> to be on (and this is averaged over 50 or 100 battles). But I'd be insane to release it like that, because it would kill the rating, and he's in the same boat :) (Oh, and just FYI, I've never found the inverse GF strategy of <a href="robowiki@AntiSurferTargeting" class=wikipagelink>AntiSurferTargeting</a> to work well at all. Surfers are just hard to hit!)
<p>
-- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
In other words, a WaveSurfing/BulletDodging<a href="robowiki@action=edit&id=WaveSurfing/BulletDodging" class=wikipageedit>?</a> movement strategy is probably best although a good somewhat random movement is probably more simple to implement. Unfortunately for me, none of my movement strategies seem to work well at all. I'm trying to tie them to my GF gun so that I can figure out how far I should be from my target. I hoping to turn my own guns back on myself and again, using a weighting system to determine which virtual bullet to dodge and how far away I should attempt to be from it. The real problem lies in the resources required for running my guns. Because they hog memory (and I think I've got leaks) I only use them a few ticks before I can fire my gun. Otherwise, I just keep my gun aimed right at the target. I can't imagine running those complex algorithms every time a bot fires their gun, that's just insane. I would have to do some serious optimization in order for that to be feasible. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
Hey, don't feel bad Ne, I seem to have a bad habit of implimenting the slowest and most inefficient versions of whatever I create. Take my best bot, Seraphim for instance, its almost classifiable as a slowbot, though it uses a 'theoretically' faster method of targeting and dodging things. Then again the movement is also more broken then a pane of glass dropped from orbit. --<a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
<p>
Heh, it probably doesn't help that my bot is extremely bloated and probably full of vestigial functions that should have been pruned by now. Wouldn't a pane of glass vaporize as it enters the atmosphere? Wow, that's some narly movement. The main problem that I seem to have with my movement now is that it tends to get stuck near the walls and vibrate. I think this has to do with my buggy implementation of antigravity movement. I've actually got it set to increase the weight of the agrav movement based on its proximity to other bots and to the walls. Once I get that little bug fixed, I'm going to attempt some wave surfing and bullet dodging. Because I'm also trying to make the <a href="robowiki@Chimera" class=wikipagelink>Chimera</a> a team bot, I could work in a system for dodging bullets that does not depend of waves. Essentially it will contain a bullets power, speed, origin, angle, and suggested distance to keep from it. My enemy waves will feed that data and my own team bots will feed other bots the info on their bullets so that I can remove my <a href="robowiki@LineOfSight" class=wikipagelink>LineOfSight</a> FirePower<a href="robowiki@action=edit&id=FirePower" class=wikipageedit>?</a> muting or else only use it when other teammates have no chance of dodging. So far, I haven't focused on the team strategy mainly because I'm still tweaking the individual aspects of the bot. I've got to make it work well in <a href="robowiki@OneOnOne" class=wikipagelink>OneOnOne</a> and Melee battles before it can be competitive in Team battles. I'm not too bad in Melee and I'm actually fairly bad in <a href="robowiki@OneOnOne" class=wikipagelink>OneOnOne</a>. I've got a lot of work to do and this is a SpareTime<a href="robowiki@action=edit&id=SpareTime" class=wikipageedit>?</a> bot. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
<UL >
<li> Actually, wouldn't the pane of glass just stay in orbit with you? If I remember my Physics classes correctly, the mass cancels out of that equation... :-P -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
<p>
<hr noshade class=wikiline size=1>
<p>
I can't believe this but I actually released 1.0 with COMPLETELY faulty aiming system. It was supposed to be choosing the firing angle based on how much each targeting method "pulled" the gun towards it. The more accurate the targeting method, the higher it's weight. However, I had the weight of EVERY method adding up to the same thing so that every weight was equal... and very high. This made my gun very inaccurate, especially at long distances. I didn't notice because many of the most predictable bots (like spinbot and walls) tend to have several targeting methods arriving at the same (or very close) conclusions. I can't believe I did something so silly. In any case, the bot should perform much better now... hopefully. I also tweaked the movement... mainly the <a href="robowiki@AntiGravity" class=wikipagelink>AntiGravity</a> movement which seemed to get the bot stuck near the walls. I actually had the walls set as attractive forces... but didn't realize it because my GoTo<a href="robowiki@action=edit&id=GoTo" class=wikipageedit>?</a> method makes sure that I don't get any closer than 50px.. and movement strategies are punished for requesting locations too close to the walls and for making the bot stand still for too long. Damn these multiple redundant features... things are broken but I just don't know what because the rest makes up it! @.@ --<a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
<UL >
<li> Don't sweat it, I'm sure a lot of us have had equally silly bugs in our bots, and sometimes for much longer. ;) IIRC, my first versions of Dookious had an insane bug in the method that determined a bot's direction (clockwise / counter-clockwise) so it was practically a random function; as you'd imagine, this would wreak havoc on any <a href="robowiki@GuessFactorTargeting" class=wikipagelink>GuessFactorTargeting</a> or <a href="robowiki@WaveSurfing" class=wikipagelink>WaveSurfing</a> system. It's always nice to realize that the rating you'd grown to accept was tainted with stupid bugs! -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
<p>
<UL >
<li>It's happened before that people find bugs and 'fix' them, and their rating drops.  Then they typically spend untold hours trying to figgure out why the flaw was better than the fix. - Martin
</UL>
<p>
<UL >
<li>And sometimes never figure out why that flaw was better, even after reiewing the complete source several times. However it is generally considered better to have a bugless bot that preforms poorly, but can be updated without leading to more problems, then having a buggy one that does great, but anything else to improve it fails. --<a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
</UL>
<p>
<UL >
<li>Y'all scared me there for a moment, I rushed over to check my rankings after reading that! Actually, there was only a nominal improvement in my rating. Granted, my rankings for 1.0 where currupted by the fact that I was running RH@H with 1.3beta... which we know allows certain bots to throw fatal exceptions while still giving them a score. This means that the results where wrong and I was probably ranked higher than I should have been. The best part of my strategy is that I feed off the weaklings in order to beat the big guys. When a bot is disabled... it really helps.
</UL>
<p>
<UL >
<UL >
<li>The only reason I can think of, for a malfunction to result in a higher score is because of it's unpredictability. Obviously, that <i>should</i> only work for movement because an unpredictable targeting method would result in an overall decrease in accuracy. --<a href="robowiki@Ne" class=wikipagelink>Ne</a>
</UL>
</UL>
<p>
<UL >
<UL >
<UL >
<li> Well, not necessarily. A bug doesn't always ruin you, sometimes it just does something a little different than intended. The <a href="robowiki@Shadow" class=wikipagelink>Shadow</a> in the rumble right now actually has a <a href="robowiki@PerformanceEnhancingBug" class=wikipagelink>PerformanceEnhancingBug</a>. In his case, he has some dynamic weights that are being reset in a way he didn't intend, but it turns out he loses a lot of rating points to "fix" that bug. (Full details on the <a href="robowiki@Shadow" class=wikipagelink>Shadow</a> page...) -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
</UL>
</UL>
<p>
<UL >
<UL >
<UL >
<UL >
<li>That's pretty crazy. I'm just suprised that my bugs didn't leave me completely crippled. I suppose that just as it is in biology, a simple mutation usually results in a decrease in viability. However, there are those rare occasions that the mutation results in an increase in viability. --<a href="robowiki@Ne" class=wikipagelink>Ne</a>
</UL>
</UL>
</UL>
</UL>
<p>
In any case, I'm suprised I was doing so well. However, what I'm most glad about is the fact that my specialization index is WAY down. Before it was 25.5 and now it's 6.6. My rank only jumped 10places... my rating only jumped 18 points. I think my greatest accomplishment is getting that specialization index down. I wanted this bot to do pretty well against most bots. I'm on my way. I think now that I've got the targeting bugs fixed, I might focus on the movement (which is where I know I need the most improvement)... but targeting is just so much fun. I've got at least two more GF guns I want to add to my array (One that segments on lateral velocity and one that segments on both distance and lateral velocity). I'm thinking that having multiple GF guns (when combined with the VG array picking the best gun) that the less segmented guns which tend to learn faster but be more inaccurate can start getting the hits in while the more highly factored guns gather information. --<a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
Oddly, my <a href="robowiki@OneOnOne" class=wikipagelink>OneOnOne</a> game has seriously suffered because of the last update... I can't imagine why. And my specialization index has skyrocketed up into the triple digits! That's really strange. It has to be my movement. Now I'm confused, those bugs helped my performance in <a href="robowiki@OneOnOne" class=wikipagelink>OneOnOne</a> battles but hurt my performance in Melee battles. That's very confusing. --<a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
If you check your results, you see quite some 'strange' results. I can't imagine Chimera would score only 68% against ad.last.Bottom for example. Seems that a client has been running that did not like your bot. Maybe your bot is using 'setAllColors<a href="robowiki@action=edit&id=AllColors" class=wikipageedit>?</a>()' or so, an older client (1.0.7) can not handle that. It will correct itself, but that can take quite some time (and I am testing teambattles right now).  -- <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
<p>
You're right. Looking over some of the supposed <a href="robowiki@ProblemBots" class=wikipagelink>ProblemBots</a> I ran a few battles of my own to see what the problem was. For instance nexus.Prototype_1.0 is a <a href="robowiki@RamBot" class=wikipagelink>RamBot</a> that I cream every time... but for some reason I score a 22.6 against. Something just ain't right. I'm not so worried now... Still... the results are skewed. That's just not nice. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
<hr noshade class=wikiline size=1>
<p>
I'm running into an interesting problem now... I'm trying to add the ability to save data files to this beast. I managed to use <a href="robowiki@Kawigi" class=wikipagelink>Kawigi</a>'s compressed read/write code. I am reading and writing bot objects easy. However, I know that where I to upload this into the rumble I would need a way to delete data files of the weaker bots. I could easily write a function that figures out who the weakest bot is... but I can't figure out two things: how to load every bot that is stored in the data file for comparison, and how to delete data files. I thought about making another file that contains only the data needed for the comparison that is essentially an index for all the data files... but I can't seem to get that to work. It would be relatively simple for me to make it where the bots aren't written to file when the quota is full... but that's not what I want to do. Any suggestions? I can't seem to find any documentation on the wiki about deleting data files. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
<a href="robowiki@Dookious" class=wikipagelink>Dookious</a> saves gun data on its opponents and deletes a data file randomly when it's near quota (I know, how sophisticated!). Here's the code:
<pre>
    long quotaAvailable = robot.getDataQuotaAvailable();
    while (quotaAvailable &lt; 2500) {
        File[] robotFiles = robot.getDataDirectory().listFiles();

        int randFileIndex =
            Math.min((int)(Math.random() * robotFiles.length),
            robotFiles.length - 1);
        quotaAvailable += robotFiles[randFileIndex].length();
        robotFiles[randFileIndex].delete();
    }
</pre>
Frankly, I didn't see a simple way to really figure out who I should keep the gun data for, so I just delete randomly.  I can fit about 250 bots in my 200 kb (using <a href="robowiki@WikiTargeting" class=wikipagelink>WikiTargeting</a> style and writing straight binary) and I don't save on opponents where the <a href="robowiki@AntiSurfer" class=wikipagelink>AntiSurfer</a> gun is much better, so I figure I've still got at the very least a 50% chance of having data on an enemy I've faced before. But it certainly could be helpful to use some actual logic to decide which ones you delete.
<p>
-- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
I may just resort to using that instead... because I would imagine loading every single bot into a hashtable in order to compare might become more than a little computationally intensive... and after a certain number of battles, this would result in slowing down drastically at the end of the 1st round of every battle (to the point of possibly throwing errors). Your solution is certainly much more elegant. I like the idea of not saving data on bots that follow certain profiles. For instance, there is absolutely no reason to save data on any of the sample bots... or any other bot that can be hit with high probability with the more simple targeting methods. So perhaps I could work in a function that does just that, does not save data on bots that are exceptionally easy to hit (a preimptive deletion if you will). Thanks! -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
On another note, my ratings seem to be droping VERY quickly. I can't imagine why... unless a slew of new (and good) bots have been introduced in the last week. I wonder if this has anything to do with the newest version of robocode and it's compatability with the rumble. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
I started my client last night, but it uses version 1.1. I have not monitored your rating, what means "VERY quickly"? New good bots won't effect your rating noticeable, it just drops when your score vs new bots is lower than expected. Your rating gets relatively stable at about 1200 battles, how many battles were fought up to the drop? --<a href="robowiki@Krabb" class=wikipagelink>Krabb</a>
<p>
I fought somewhere around 2000+ battles. I set my client (running 1.1.3) and it ran for a good three days straight. After being gone for a week, I come back to see my bot has gone from a rank of 70 (momentum of 2) to a rank of 109 (momentum of -39)! I can't imagine that my bot suddenly got really bad out of nowhere. This version of the bot is not saving files yet, so there couldn't be any performance issues that build up over time. I know that I occasionally get disabled in 1.3 for array out of bounds exceptions. Other than that, I can't think of anything else. As you can imagine, I'm quite confused. I would like to figure out what's going on. If someone is running a client with a version that has my bot performing badly, I would like to test my bot in that version so that this doesn't keep happening. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<UL >
<li>You should grab a copy of 1.0.7, the final release by the original author.  The new author has changed the interface, adding method calls (such as changing the color of your bullets) that do not exist in the earlier version, which would cause your bot to crash immediately if someone is running the Rumble using that version for its reliability.  Normally this wouldn't be a problem because you'd expect to get a score of 0, which the Roborumble server ignores, but sometimes you end up with a score (e.g. if the other bot crashes for the same reason, or loses a round due to throwing some other exception) and it gets recorded.  ... Bottom line though is that if you want to ensure that your bot doesn't crash due to a version conflict, just limit your bot to the interface provided in 1.0.7. -- Martin
<li> [Edit conflict] I must second Martin largely, if your bot works with 1.0.7 then there should be no problem. On the other hand, the differences in robocode-engine between 1.0.7 and 1.1.3 are minimal if any, and the only problems expected there are those 'setColor' things. As you are talking about melee, the scoring as mentioned by Martin is not valid in your situation as in melee even <a href="robowiki@SittingDuck" class=wikipagelink>SittingDuck</a> does score some survivalpoints. In melee it is very rare that red (or green) results appear in the PBI as the differences ary very small. Note that there are more bots with strange results, like <a href="robowiki@SandboxDT" class=wikipagelink>SandboxDT</a> and <a href="robowiki@SandboxLump" class=wikipagelink>SandboxLump</a>. Probably some battles with 1.3.x were (accidentaly) uploaded.  -- <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
<UL >
<li>I'm actually setting the bullet color to red... that could be the problem. I'll change that in my next update. Also, would all the paint commands that I use for debugging cause problems? -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<li>The whole onPaint() routine is ignored if not explicitly activated, so there would be no problem in any robocode version.  -- <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
</UL>
</UL>
<p>
<hr noshade class=wikiline size=1>
I just found out something rather annoying. Apparently there was yet another bug in the way I evaluate the accuracy of each targeting method. The process is simple, I start from the origin of the wave, find the actual point on the wave that the target intersects, Find the point the targeting method proposed, then evaluate the distance. If the distance is less than 16 it's a hit, otherwise it's a miss, (I was thinking about making anything less than 22 a half hit for). In any case, apparently when you make one Point2D.Double = another, it syncs the two. It needs to be declared as Point2D.Double = new Point2D.Double(x,y) in order to be completely separate. I can't help but wonder how many instances, I've got going screwy because they're synced up! Beyond that bug fix, I added data file capability (though it doesn't seem to help much) and I fixed my colors so they don't disable me when using previous versions of robocode. Hopefully that will take care of my rating issues. Once I iron out the bugs well enough for my liking, I'll start working on new things. My main concern now is that my wave evaluation is still off... apparently it says I only hit sitting duck 70% of the time... It probably has something to do with how I arrive at the angles. I'm sure there's a better way to do it. Thanks everyone for the advice. -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
<p>
Well, this is actually a "feature" of Java, something you just need to know about to make use of correctly. If you want to make a new copy of an object but have separate objects afterwards, the convention is to use object.clone() to return a new instance that is identical to the original. An object variable is actually a reference to an object, not an object in and of itself. So (like you said) <code>obj1 = obj2 = obj3 = new Object()</code> will set those 3 objects to the same value: a pointer to a certain object in memory. If you later made all three of those Object references point to other objects, that old unreferenced Object would be picked up by the garbage collector later on. All of this can be useful if you know to use it correctly, but painful if you don't (as you've just found out). (For what it's worth, I think we've all made this mistake at some point - at least I have.) -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
I always use (at least I think and hope so) the setLocation method of a Point2D, I will scan through my code though, you'll never know.   -- <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
<p>
I can see how that would be a useful feature. I should have realized that using that method connected things instead of copying data. I use the same robot tracking method as <a href="robowiki@SnippetBot" class=wikipagelink>SnippetBot</a> if I'm not mistaken and somehow the target object seems to stay right in sync with the data in the hashtable. I just hope that similar mistakes are not sprinkled through the rest of my code. On the upside, this newest version is doing very well, the ability to save data between battles is super helpful. I really need to learn how to chop bots up and just program better. This monster is starting to be a handful... all in one file. In any case, thanks for all the help, I REALLY should have gotten on here sooner... perhaps then it wouldn't have taken me 3 years to make a decent bot! -- <a href="robowiki@Ne" class=wikipagelink>Ne</a>
</div><hr class=wikilinefooter>
<div class=wikifooter><form method="post" action="robowiki" enctype="application/x-www-form-urlencoded">
<a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<a href="robowiki@action=edit&id=Chimera" class=wikipageedit>Edit text of this page</a> | <a href="robowiki@action=history&id=Chimera">View other revisions</a><br>Last edited September 24, 2007 8:42 EST by pool-71-164-236-191.dllstx.fios.verizon.net <a href="robowiki@action=browse&diff=1&id=Chimera">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /></form></div>
</body>
</html>