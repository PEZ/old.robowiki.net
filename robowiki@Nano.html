<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD><TITLE>Nano - Robo Wiki -= Collecting Robocode Knowledge =-</TITLE>
<META NAME='KEYWORDS' CONTENT='Nano'/>
<LINK REL="stylesheet" HREF="/robodocs/wiki.css">
</HEAD><BODY BGCOLOR="white">
<div class=wikiheader><h1><a href="robowiki?Robo_Home"><img src="/images/RoboWiki.png" alt="[Home]" border=0 align="right"></a><a href="robowiki?back=Nano">Nano</a></h1><a href="robowiki?Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki?Changes" class=wikipagelink>Changes</a> | <a href="robowiki?action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<hr class=wikilineheader></div><div class=wikitext>Yes, I came up with this name long before I got involved in Robocode, so it has nothing to do with codesize, heh.  It has to do with being physically small.  As in nanometer.  I play Unreal Tournament competitively, and I liked the sound of "nano".
<p>
Currently, my only released bot is <a href="robowiki?PerceptBot" class=wikipagelink>PerceptBot</a>.  I have an unreleased megabot named Claire that was to be a proof-of-concept for an RLS-filter-based predictor/gun, but the filter ended up diverging in the majority of cases, so Claire won't ever see the light of day.  My current brainchild is Statistician, a proof-of-concept for two completely new algorithms -- a statistics-based aiming algorithm (using either <a href="robowiki?Wave" class=wikipagelink>Waves</a> or <a href="robowiki?VirtualBullets" class=wikipagelink>VirtualBullets</a>) that implements a kind of dynamically adjustable <a href="robowiki?BestPSpace" class=wikipagelink>PSpace</a>, and a completely original (and very complex) curve-flattening movement algorithm, designed specifically to handle curve-flattening for multiple bullets at once.
<p>
<b>Update 6/2/03:</b> I have scrapped Statistician as a competitive bot.  The movement algorithm was too CPU-intensive (it was basically a brute-force search with adjustable granularity), and the segmentation done on his statistics was too fine and too random.  I would, however, like to announce <a href="robowiki?Tax" class=wikipagelink>Tax</a>.  I found a research paper for an amazing new algorithm in my new subscription to IEEE Neural Network Transactions, and it turned out to be fairly easy to implement.  <a href="robowiki?Tax" class=wikipagelink>Tax</a> will be (I think) the first bot to use a neural network to classify enemy movement, allowing him to switch between guns on the fly, depending on the situation.
<p>
<b>Update 1/22/04:</b> Wow, it's been awhile.  After spending months of effort on high-falooting ideas, including <a href="robowiki?PatternSegmentedStatGun" class=wikipagelink>PatternSegmentedStatGun</a>, and some stupid early adaptive movement ideas, I have learned a bit about what is and is not feasible in Robocode.  I am now in the process of cementing my knowledge of the basics of competitive Robocode, including modern segmented stat guns and a normal flattening movement.  <a href="robowiki?Unnamed" class=wikipagelink>Unnamed</a> is the somewhat paradoxically named bot that is currently housing my first solid gun implementation, ever (I am very proud of my fourth place in the <a href="robowiki?TargetingChallenge" class=wikipagelink>TargetingChallenge</a>!).  I am currently stuck on <a href="robowiki?WallSmoothing" class=wikipagelink>WallSmoothing</a>, which seems to be fairly necessary in a good movement, but which I have been unable to nail down.  Does anyone want to share how it's done? :)
<p>
Email: knardi@calpoly.edu<br>
AIM: randomx
<p>
<p>
-nano
<hr noshade class=wikiline size=1>
It took a year before anyone corrected that spelling on the <a href="robowiki?ReadMe" class=wikipagelink>ReadMe</a> page. I'd say that we now have taken the next step in wiki-land. =) -- <a href="robowiki?PEZ" class=wikipagelink>PEZ</a>
<p>
Wall smoothing is heavily dependent on your implementation of movement. How to do it for an orbital movement that selects direction and angle of attack is completely different from a movement that selects points. One good example is in <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a>. The general principle is to translate your point of impact back inside the acceptable battlefield, head to it, translate the subsequent point of impact, and so forth until you're perpendicular to the wall. -- <a href="robowiki?Kuuran" class=wikipagelink>Kuuran</a>
<p>
I suppose that that is the algorithm for <a href="robowiki?WallSmoothing" class=wikipagelink>WallSmoothing</a> if using a go-to movement, however, most rotation is done per tick (in an attempt to stay perpendicular to the enemy), and in this case it becomes impossible to merely translate the point of impact.  When I attempt something like this, I have problems with bouncing back and forth between two angles (the one inside the battlefield and the one perpendicular to the enemy).  Has anyone had this problem and developed a good solution? -- <a href="robowiki?Nano" class=wikipagelink>nano</a>
<p>
As I said, <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a> has something like this. But when you adjust to the new angle aiming at inside the battlefield you should still be headed for a wall collision, that's not actually gone until you've come parallel to the wall. Ensure that your normal movement code can't assert it's angle if there is wall collision impending and ensure that you're aiming for the legal portion of battlefield closest to the point of impact and you shouldn't be having this problem.
<p>
<a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a> closes on the enemy if a wall collision is impending and moves away from the enemy at all other times to achieve the smoothing effect. It just sets an optimal distance and shrinks it until it's projected movement isn't leaving the battlefield. The turn to close to the distance from the enemy that's still inside the battlefield (basically the distance between the enemy and the wall) is also the turn required to just miss the wall, for obvious reasons. Either method should provide the results you're after.
<p>
-- <a href="robowiki?Kuuran" class=wikipagelink>Kuuran</a>
<p>
"When you adjust to the new angle aiming at inside the battlefield you should still be headed for a wall collision."  This just doesn't make sense, unless by "headed for a wall collision" you mean "aimed toward a wall", which is always, of course, true.  If you translate some line projected in front of your bot to be inside the battlefield, it follows that that line is now inside the battlefield, and thus by definition, you are not headed for a wall collision.  Thus the next tick will not use the correction as it should, and will instead rotate into the wall (to be more perpendicular to the enemy).  This oscillation between the two angles is evident in all three of my attempts at real-time <a href="robowiki?WallSmoothing" class=wikipagelink>WallSmoothing</a> (that is, not using goTo).  It is obviously just a bug in my code (or perhaps a flaw in my approach), but I will look into this again in a few days.  For tonight I am running the TC again with a new stat segmentation algorithm.  My fingers are crossed.  -- <a href="robowiki?Nano" class=wikipagelink>nano</a>
<p>
There's nothing in <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a>'s <a href="robowiki?WallSmoothing" class=wikipagelink>WallSmoothing</a> approach that depends on a goTo() function. I just happen to use goTo() to give the right setAhead() and setTurn() commands, implementing <a href="robowiki?BackAsFront" class=wikipagelink>BackAsFront</a> while at it. <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a> uses an orbital movement approach that could do very well without the goTo() for driving around. What <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a> assumes is that its enemy is inside the battle field. A reasonable assumption, in'it? =) -- <a href="robowiki?PEZ" class=wikipagelink>PEZ</a>
<p>
Obviously your approach is wrong. I don't see why you're so hung up on goTo(), as PEZ said, but anyway, if you translate your destination inside the battlefield all you're doing is wall avoidance. When you head for the point nearest the point of impact unless your angle of approach was extremely shallow you're still going to be heading for a wall collision, just at a slight delay, until you've finished the smoothing and are riding the wall. Prevent the perpendicular to your opponent angle from asserting itself while this is happening and project your movement before applying the select change in angle (after picking the angle before putting it into setTurnRightRadians<a href="robowiki?action=edit&id=TurnRightRadians" class=wikipageedit>?</a>() or whatever use that angle to project if you're going to have to smooth with it, and do so before it asserts itself). -- <a href="robowiki?Kuuran" class=wikipagelink>Kuuran</a>
<p>
You could regard <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a>'s way of doing <a href="robowiki?WallSmoothing" class=wikipagelink>WallSmoothing</a> as a flexible "blind mans' stick" with a little wheel at the end. RMB is sticking out this stick in the direction it wants to move. When the stick hits the WALL_MARGIN it "folds" and "rolls" towards the enemy until it has room to extend to its full length. Then the bot moves there. Does this make sense? It is how I came up with the technique to begin with. -- <a href="robowiki?PEZ" class=wikipagelink>PEZ</a>
<p>
Yes, that's the approach I am using (projecting a "stick" in front of my bot and translating it inside the battlefield).  I will look at <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a>'s code more closely and see how I can translate it to my code.  Thanks much for the help!  It sounds like this is much easier than my failures at coding it had led me to believe.  -- <a href="robowiki?Nano" class=wikipagelink>nano</a>
<p>
Just making sure it is clear; RMB does no translation of the destination point. It just iteratively moves the end of the stick closer and closer to the enemy until the stick end is inside the battle field (with some margin). I think this is much better than translation. Like Kuuran says, that's just <a href="robowiki?WallAvoidance" class=wikipagelink>WallAvoidance</a>, not <a href="robowiki?WallSmoothing" class=wikipagelink>WallSmoothing</a>. Check <a href="robowiki?Tityus" class=wikipagelink>Tityus</a> movement code for a way to control just how much smoothing you dare do. -- <a href="robowiki?PEZ" class=wikipagelink>PEZ</a>
<p>
Yes, that is the idea I meant to communicate.  My first attempt did do this "translation" by mathematically translating the point instead of iterating over closer and closer angles, but my current attempt follows the pattern you describe.  Hopefully I can get this fixed by the end of tonight so that I can move on to more interesting things. :) -- <a href="robowiki?Nano" class=wikipagelink>nano</a>
<p>
Thanks for the help again, and the firm bludgeoning!  After reading Raiko and <a href="robowiki?RandomMovementBot" class=wikipagelink>RandomMovementBot</a>'s wall-smoothing code I finally got mine to work.  My problem?  I had a bug in my getAngle function (to get the absolute bearing between two points), in that it did not return Robocode angles.  That didn't matter for my stat gun, but it mattered <i>everywhere else</i>.  Now Unnamed's movement is siiilky smooooth.  I also implemented a neat bullet-power selection algorithm and my patented segment-balancing algorithm (which actually only helps my aim a very little bit, but it does help).  Next step: some semblance of a good movement.  I may try a little <a href="robowiki?CoolMovement" class=wikipagelink>CoolMovement</a> + adaptive movement, we'll see if I can get anything to work. -- <a href="robowiki?Nano" class=wikipagelink>nano</a>
</div><hr class=wikilinefooter>
<div class=wikifooter><form method="post" action="robowiki" enctype="application/x-www-form-urlencoded">
<a href="robowiki?Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki?Changes" class=wikipagelink>Changes</a> | <a href="robowiki?action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<a href="robowiki?action=edit&id=Nano" class=wikipageedit>Edit text of this page</a> | <a href="robowiki?action=history&id=Nano">View other revisions</a><br>Last edited May 4, 2006 21:31 EST by <a href="robowiki?UnderDark" title="ID 5263 from d149-67-30-72.try.wideopenwest.com">UnderDark</a> <a href="robowiki?action=browse&diff=1&id=Nano">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /></form></div>
</body>
</html>