<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD><TITLE>Sin Varg - Robo Wiki -= Collecting Robocode Knowledge =-</TITLE>
<META NAME='KEYWORDS' CONTENT='Sin, Varg'/>
<LINK REL="stylesheet" HREF="/robodocs/wiki.css">
</HEAD><BODY BGCOLOR="white">
<div class=wikiheader><h1><a href="robowiki@Robo_Home"><img src="/images/RoboWiki.png" alt="[Home]" border=0 align="right"></a><a href="robowiki@back=Sin+Varg">Sin Varg</a></h1><a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<hr class=wikilineheader></div><div class=wikitext>I'm a new Robocoder, good programmer but bad english speaker ;)
<p>
<h4>Profile</h4>
I'm a german Robocoder since Nov 2006, born 1983. I started programming very early with an age of about 7 years. But only later with about 12 years I wrote nice graphical programs and little games in AmigaBasic<a href="robowiki@action=edit&id=AmigaBasic" class=wikipageedit>?</a> but my coding style was bad ;)
As I was 16 I learned Turbo Pascal, loved it. It was the first time I learned how to write bigger programs and I liked to write libraries. Assembler helped me to optimize my libraries.
<p>
2000 I learned C++. C++ was and is the best language for me to write efficient programs. This was the first time I learned how easy and powerful pointers are. I like to write classes, data structures and thinking about algorithm and efficiency. Suddenly nothing that would be impressive for someone in my age at that time.
<p>
2004 I startet to study Informatik. My knowledge about Java and mathematics grew rapidly there. I learned Java, which allows very easy programming. But I am missing templates and efficient programming.
<p>
<h4>How I found Robocode</h4>
In Oct 2006 I searched free games and found: DarwinBots<a href="robowiki@action=edit&id=DarwinBots" class=wikipageedit>?</a> a "programming game", never heared that before.
The years before I asked myself: 'If I would write a game, where a "player" must write an AI which plays the game, would ever someone in the world play this game?
It would be fine, if there would be a game, where AIs fight each other in a competition.'
And then I found DarwinBots<a href="robowiki@action=edit&id=DarwinBots" class=wikipageedit>?</a>, a programming game. DarwinBots<a href="robowiki@action=edit&id=DarwinBots" class=wikipageedit>?</a> itself wasn't good (written in Visual Basic), but an easy language and good interface. I tried to write Bots but the game always crashed with my special Bots ;)
<p>
But important was, I found the words: "programming game" and searched for them.
Finally I got some sites where programming games were listed, looked at many programming games and... most of them wasn't really good or the community was dead.
<p>
I looked at Robocode ( community alive ), Robocode open source ( good ). Robocode itself is easy to use, easy to write own bots... but
before I can start to write a Bot I must know everything in detail and found out, that Robocode itself isn't written good but uses nice tricks to learn from.<br>
I'm thinking about writing a better programming game, there are many points that I could do better.<br>
It's not easy to unterstand what exacty happens in Robocode and how it works for a newbie.
But my decision is, to try to write at least one really good Robot.
<p>
<p>
<h4>What I would do better</h4>
I would offer a simple interface for a Robot which allows to get all inputs, let the Bot work with the data and return an output on every tick/cycle/step.
To make it easy to write simple bots, I would offer classes that extends or use this interface, preprocesses the inputs and let the Bot simulate events which depends on the inputs. This extended Robots would offer some methods for easy movement, too.
I figured out some easy IO and internal states of Robocode-Robots for a simplification, I listed them in <a href="robowiki@SimpleRobot" class=wikipagelink>SimpleRobot</a>.
<p>
<h4>Status</h4>
I wrote a little tool that shows me, where a Robot can move to from current tick until n ticks in the future. That will help to create a good Robot.
<p>
My first Robot is going to be a pure 1vs1 Robot, the next will be a melee and then perhaps I try to write Robots for team vs team battles, but I didn't find a competition for melee fight of teams ( size of 5000 x 5000 would allow it ).
<p>
<hr noshade class=wikiline size=1>
<p>
Welcome to the <a href="robowiki@RoboWiki" class=wikipagelink>RoboWiki</a>! If you're interested, there's been a discussion about Robocode 2 on the <a href="robowiki@Robocode" class=wikipagelink>Robocode</a> page lately, it sounds like you have some solid ideas about programming games in general. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
Wilkommen.  I think your suggestion of a team melee (like 10 teams fighting each other) is the first time I've heard the idea.  That would take a <i>long</i> time to process, but it sure would be fun to watch. -- <a href="robowiki@Martin_Alan_Pedersen" class=wikipagelink>Martin</a><br>Edit: I suggest that you use the <a href="robowiki@AdvancedRobot" class=wikipagelink>AdvancedRobot</a> rather than Robot as the basis for your competitive bots.  The primary difference is that Robots only process one instruction per turn, whereas AdvancedRobots<a href="robowiki@action=edit&id=AdvancedRobots" class=wikipageedit>?</a> can process multiple instructions per turn.  It is beneficial to be able to turn your radar, gun, and tank, move forward or backward, and fire all in the same turn.  Robots have to pick one.  It is not unheard of to write an interface for queueing up your turn's instructions.  I have a class in Ugluk that acts as a bean for retrieving state and storing instructions.  I also have some methods for consistent logic such as isGunCool(), areAnyOpponentsLeft(), isTankDisabled(). -- Martin
<p>
The basic idea was, that Robot is easier to use than <a href="robowiki@AdvancedRobot" class=wikipagelink>AdvancedRobot</a>, I didn't know that people use Robot because Robot is weak. A real <a href="robowiki@AdvancedRobot" class=wikipagelink>AdvancedRobot</a> does never need the blocking methods from Robot.<br>
I experimented with <a href="robowiki@CodeSize" class=wikipagelink>CodeSize</a> and found a way to let nearly every <a href="robowiki@AdvancedRobot" class=wikipagelink>AdvancedRobot</a> fit in a <a href="robowiki@MicroBot" class=wikipagelink>MicroBot</a>. The only problem would be, that this <a href="robowiki@MiniBot" class=wikipagelink>MiniBot</a> would run extremly inefficient and needs very much memory.<br>If the size is increased to <a href="robowiki@MiniBot" class=wikipagelink>MiniBot</a>, an fitted <a href="robowiki@AdvancedRobot" class=wikipagelink>AdvancedRobot</a> can run more efficient and needs less memory.<br>I would like to translate a high competitive Robot (which may have any codesize) to a small sized <a href="robowiki@MicroBot" class=wikipagelink>MicroBot</a> or <a href="robowiki@MiniBot" class=wikipagelink>MiniBot</a>. I tested this only with some very simple robots. -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a>
<p>
Go ahead and attempt it on any of my bots, such as <a href="robowiki@Velshea" class=wikipagelink>Velshea</a>, <a href="robowiki@Chase-san/Beowulf" class=wikipagelink>Beowulf</a> or <a href="robowiki@Tyrra" class=wikipagelink>Tyrra</a>. All of those are megabots, with Velshea taking the bottom rung in size. Good luck. -- <a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
<p>
Thanks, I looked at your robots and have chosen the one with the best score: <a href="robowiki@Tyrra" class=wikipagelink>Tyrra</a>. After I simplified it to convert it, I saw that the bot isn't complex - a good condition for the conversion into interpretable stringcode.<br>
The idea of my <a href="robowiki@MicroBot" class=wikipagelink>MicroBot</a> is, that the real program is stored in a String and the bot interprets this codestring. I wrote a <a href="robowiki@MicroBot" class=wikipagelink>MicroBot</a> which supports nearly every event and file access, but it has only 3 commands. Theoretical everything is possible with this bot, but i think the efficiency will be very low. The interpreted version of <a href="robowiki@Tyrra" class=wikipagelink>Tyrra</a> could use much more commands inclusive some math functions from java, because it doesn't need much events nor file support. In fact, every interpreted robot should use an own specialized interpreter-robot, which offers only the functions he really needs. This makes it difficult to write a flexible compiler, which compiles one high language code to any specialized codestring format.<br>
<br>Because writing an interpreted bot is not easy without compiler and the development of a compiler plus a robot that must be compiled with it would consume very much time, I should ask (where?) if this kind of robots wouldn't be forbidden, because it shifts executable code ( an own for each robot specialized format, not java byte code ) into data ( a String which don't increase codesize ). -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a><br>
<p>
I don't think it would be forbidden, but it might be frowned upon. --<a href="robowiki@David_Alves" class=wikipagelink>David Alves</a>
<UL >
<li>Robocode is one of things where you only get out of it what you put into it.  If you want to copy other people's code and slap your name on it, you aren't getting much out of the experience.  If you want to spend months on end writing everything on your own, it is likely more satisfying and educational.  If you want to write a bot that can operate by interpreting string instructions, that's probably a nifty and educational experience.  If you want to take that interpreter and instead operate a robot that you didn't write, I doubt you'll get much out of the experience, and few people if any will congratulate your apparent success.  If on the other hand you write both the interpreter and instructions being interpreted, and it is able to perform adequately with the present time-per-turn allowance (presently about 22ms) so that it is competitive, I think it would be a justifiable entry in a codesize restricted competition.  -- Martin
<UL >
<li>In response to what Martin has to say I think that building the interpreter is the first hurdle here, tyrra is open source and infact about half of it isn't anything more then a conversion of basicSurfer(the reason I removed it from the rumble). Writing a robot might not be some peoples forte, but figuring out a new way to write a robot might. --<a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
</UL>
</UL>
<p>
I'm glad you feel that Tyrra isn't overly complex, when I made it she was the most complex bot I ever made. However the soon to be newest version of velshea will top it I hope. An interesting way of saving codespace, however the interpreter itself wills till take up space, but if you can fit tyrra into a micro or mini let me know. -- <a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
<p>
<UL >
<li>That sounds like I should create my own real robot first ;)<br>Ok, I am still learning how robocode works and found a way to communicate with other robots (without using <a href="robowiki@TeamRobot" class=wikipagelink>TeamRobot</a>). If I use this, the result would be that in melee fights all my bots (if more than one bot is from me in battle) fight together against every enemy and then if all enemies are finished they kill each other in a way, that the score is maximized for each of my robots.<br>The communication itself is limited to some bits per tick, but it's enough to detect friends and share some scanned robots or waves. BUT, if an enemy knows the communication protocol, he can fake being a friend and kill'em. How it works: The data is stored in the velocity and heading of a robot. Every robot can read this data, if it scans the sending robot. Instead Velocity 3 it uses 3.000XXXX5 where XXXX is the data, 8 is cutted down to 7.999XXXX5. Good idea, already in use or just unfair? -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a>
<UL >
<li>Is a bit complex and I don't know of the accuracy you could get out of it. Also you would have to pack a huge amount of data into only 4 numeric characters. That small amount of data couldn't be used for much more then conveying that its a friend or perhaps more or less which direction it might fire next(but if you do such and an enemy can read it then you'll never hit em). Its a okay idea in theory, but wheather or not the robo api can convey such a velocity to an enemy or friend is unknown to me. Plus once you do impilment it, all everyone else has to do is impliment something that will fool your bots into thinking your a friend and soon your bots will be ranked really low (as such you gave yourself more of a weakness then an advantage).  -- <a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
<li>Melee is about you against nine others. It is a clever idea, although checking if another bot of 'your' package is present is as simple as checking (part of) the name. However I do regard it as cheating and I think most of us will. This method can be used in Teams and <a href="robowiki@TwinDuel" class=wikipagelink>TwinDuel</a>, if it can be as reliable as the current messagehandling. Note that currently a message can be sent every tick and you do not have to scan your teammate.  -- <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
<UL >
<li>I know TeamRobots<a href="robowiki@action=edit&id=TeamRobots" class=wikipageedit>?</a> can communicate much better, the idea was to use communication in melee to ally with other robots. The "3.000XXXX5" was just an example which everyone can understand quickly, because it's decimal. The mantissa of a double has a size of 52 Bits. If I would use only 36 Bits of them to store data, there are 16 bits left for movement information ( and some to prevent data to be corrupted from intern calculation ). I tested it with 32 data bits and 4 checksum bits and works well. That are 64 data bits ( because 2 doubles can be used to store data ) for each tick, enough to do more complex communication. Practical it'll not be used because it's like cheating. -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a>
</UL>
</UL>
</UL>
<br>
I read something about presaved data at <a href="robowiki@Dookious" class=wikipagelink>Dookious</a>. It wouldn't be against any rules to store the statistical data from many fights at home in static arrays at compile time (without writing it into file at runtime)? There could be stored many megabytes of data (I didn't test it), much more than only 200kb and the data file can be used to store compressed statistical data about every unknown enemy at runtime. I would prefer, that data is not allowed to be presaved - but I think there is no way to check if a bot presaves data and how much a bot presaves. Of course, if a bot has a huge class size with a relative small codesize, you can assume that it presaves data, but it could be possible that it just uses some data tables to increase performance. -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a>
<p>
One version of <a href="robowiki@Dookious" class=wikipagelink>Dookious</a> did pre-save data, it gained about 10-15 points for it. The only "rule" about pre-saved data is that you are not allowed to package more data than the 200kb quota; Robocode itself only checks the quota when a bot is writing out data, so you could otherwise pre-save any amount of data. But yes, you could package data into your code at compile time without breaking any rules. I'm not sure if there's a file size limit on the .jar itself anywhere, but there might be...? -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<UL >
<li> I'm quite sure that there is no size limit on the .jar file itself. When you download a .jar file, you are avare of how much space it costs, and therefore Robocode does not (need to) check it's size. In the case of the pre-saved data, the fixed size quota has been defined for two reasons. The first one being that a Robot should not be allowed to use as much harddisk space as it want (imagine a robot that spends Gigabytes of disk space ;-). Hence, the file size must be limited. The quota of 200kb was made to make it equal between all robots no matter how much harddisk space that is available (the limit was set in 2001). The other reason being, that the pre-saved data serves as the "dynamic" part of a robot that can change (learn) between battles, where as it is not possible to change the data stored in the static .jar file. ;-)  --<a href="robowiki@Fnl" class=wikipagelink>Fnl</a>
<UL >
<li> Ok, but a robot could store presaved data in code ( array ) as much as he needs ( let's be 2MB to keep size small ) and additional use his 200kb file to store dynamic data for every unknown (newer) robot. -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a>
<li> Yes, you can do this. You could also manually change to the 200k limit on your computer, fill your directory up with megabytes and megabytes of data, and upload the jar. Even though other people have their limit set at 200k, robocode won't delete the excess data. This works, and has been done. However these techniques to circumvent the 200k limit aren't good sportsmanship in my opinion. --<a href="robowiki@David_Alves" class=wikipagelink>David Alves</a>
<UL >
<li> Well, let's write some fairplay rules somewhere, because Robocode seems to offer some ways to play unfair. I just seek for every advantage I can take, but the 'tricks' I mentioned here are just some, that looks unfair to me. -- <a href="robowiki@Sin_Varg" class=wikipagelink>Sin Varg</a>
<li> Writing up rules invites people to do unethical things that still follow the letter of the rules.  Maybe you should just have some fun writing your bot and not worry about whether it is a legitimate competitor or not.  It's not like there is a cash reward for placing in the Roborumble. -- Martin
<UL >
<li>There's not?! --<a href="robowiki@Wcsv" class=wikipagelink>wcsv</a>
</UL>
</UL>
</UL>
</UL>
<p>
I had an idea how to optimize the distance function with a lookup table. But tests had shown, that arrays are too slow in Java.<br>Really interesting was, that Math.hypot(x,y) needs nearly 30 times more time than Math.sqrt(x*x+y*y), but why?!<br>
Another strange function: double cos = Math.cos(x); double sin = Math.sqrt(1-cos*cos); needs only 3/4 of the time which double sin = Math.sin(x) needs without calculating the cosine!<br>I mean, variant 1 gives me the sin and cos, variant 2 only the sin and variant 2 is slower than variant 1. That are just strange performance data that I collected today on my AMD Athlon64 3000+. The biggest surprise was, that Math.hypot is extremly slow and Math.sqrt is extremly fast.<br>I would like to know how fast the functions are on other machines, because I'm really confused which functions I should use now to get highest performance.
<p>
<UL >
<li> What did you use to measure this performance? I'm not sure your computer's CPU is capable of accurately measuring these unless you were measuring millions of each of these calculations in a batch. In the end, personally, I've found that there's much more speed to be gained in a clean, <a href="robowiki@KISS" class=wikipagelink>KISS</a>, <a href="robowiki@OAOO" class=wikipagelink>OAOO</a> design than in optimizing the little things; but I'm still down to compare the squares of distances instead of a costly call to Math.sqrt if it doesn't make the code too hard to read. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
<p>
The reason Math.hypot is so slow is that it doesn't square the arguments first. The idea is to let you call Math.hypot with extremely large numbers and not get overflow. By the way, you really shouldn't use that function, not everyone is running the latest java, and that function wasn't in 5.0. --<a href="robowiki@David_Alves" class=wikipagelink>David Alves</a>
<UL >
<li>Did you mean "in prior to 5.0"? -- Martin
</UL>
</div><hr class=wikilinefooter>
<div class=wikifooter><form method="post" action="robowiki" enctype="application/x-www-form-urlencoded">
<a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<a href="robowiki@action=edit&id=Sin_Varg" class=wikipageedit>Edit text of this page</a> | <a href="robowiki@action=history&id=Sin_Varg">View other revisions</a><br>Last edited November 21, 2006 23:38 EST by <a href="robowiki@Martin_Alan_Pedersen" title="ID 7952 from 066.137-60-66.DIA-subnet.surewest.net">Martin Alan Pedersen</a> <a href="robowiki@action=browse&diff=1&id=Sin_Varg">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /></form></div>
</body>
</html>