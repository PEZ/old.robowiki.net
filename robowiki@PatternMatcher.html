<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD><TITLE>PatternMatching - Robo Wiki -= Collecting Robocode Knowledge =-</TITLE>
<META NAME='KEYWORDS' CONTENT='Pattern, Matching'/>
<LINK REL="stylesheet" HREF="/robodocs/wiki.css">
</HEAD><BODY BGCOLOR="white">
<div class=wikiheader><h3>(redirected from <a href="robowiki@action=edit&id=PatternMatcher" class=wikipageedit>PatternMatcher</a>)</h3><h1><a href="robowiki@Robo_Home"><img src="/images/RoboWiki.png" alt="[Home]" border=0 align="right"></a><a href="robowiki@back=PatternMatching">PatternMatching</a></h1><a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<hr class=wikilineheader></div><div class=wikitext>A method of <a href="robowiki@Targeting" class=wikipagelink>Targeting</a>.
<p>
Check out <a href="robowiki@RecursivePatternMatching" class=wikipagelink>RecursivePatternMatching</a>
<p>
One quite simple strategy is to:
<OL >
<li> Record your enemy's movements
<li> When estimating a future location you:
<OL >
<li> Try to find a match in this recorded history matching the recent movements.
<li> Play the recorded "movie" from this match for <a href="robowiki@BulletTravelTime" class=wikipagelink>BulletTravelTime</a> time
</OL>
</OL>
<p>
I got most of the inspiration for <a href="robowiki@Marshmallow/PatternMatcher" class=wikipagelink>Marshmallows pattern matching</a> from here: <strike><a rel="nofollow" href="http://www.realj.com/robots/MogBot.html#aiming">http://www.realj.com/robots/MogBot.html#aiming</a></strike>
<a rel="nofollow" href="http://web.archive.org/web/20040213005719/http://realj.com/robots/MogBot.html#aiming">http://web.archive.org/web/20040213005719/http://realj.com/robots/MogBot.html#aiming</a> (- Voidious) 
<p>
<p>
<H4>Resources</H4>

<UL >
<li> See also <a href="robowiki@SymbolicPatternMatcher" class=wikipagelink>SymbolicPatternMatching</a> to see how to build an specific implementation.
<li> For some interesting information about <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> parameters, take a look to <a href="robowiki@Parakeet" class=wikipagelink>Parakeet</a>.
<li> For some pattern matching code, you can take a look to <a href="robowiki@NanoLauLectrik" class=wikipagelink>NanoLauLectrik</a> and <a href="robowiki@Moebius" class=wikipagelink>Moebius</a>. -- <a href="robowiki@Albert" class=wikipagelink>Albert</a>
<li> <a href="robowiki@Marshmallow/PatternMatcher" class=wikipagelink>Marshmallow/PatternMatcher</a> - code for a <a href="robowiki@MogBot" class=wikipagelink>MogBot</a> style implementation
<li> <a href="robowiki@PatternMatching/PatternRating" class=wikipagelink>/PatternRating</a> - how to rate the closeness of a pattern
<li> See the <a href="robowiki@PatternMatcherChallenge" class=wikipagelink>PatternMatcherChallenge</a> for a good unit test designed by <a href="robowiki@Vic" class=wikipagelink>Vic</a> to debug and clean up your pattern-matcher against.
<li> <a href="robowiki@FoldedPatternMatcher" class=wikipagelink>FoldedPatternMatcher</a> illustrates an optimized symbolic pattern patcher.
<li> <a href="robowiki@PatternMatching/SingleTick" class=wikipagelink>/SingleTick</a> takes a slightly different approach, with some nice results.
<li> <a href="robowiki@StatisticalPatternMatching" class=wikipagelink>StatisticalPatternMatching</a> is a combination of <a href="robowiki@LogTargeting" class=wikipagelink>LogTargeting</a> and <a href="robowiki@StatisticalTargeting" class=wikipagelink>StatisticalTargeting</a>.
</UL>
<p>
<p>
<hr noshade class=wikiline size=1>
The starting point for pattern matching is the assumption that a bot will repeat its movements, so if you are able to find some movement in the past that is similar to the current bot's movement, you will be able to predict its future position by reproducing past movements.
<p>
Pattern matching and virtual bullets have proved the best targeting strategies so far (top 10 bots in eternal rumble use one or the other). 
<p>
It has some advantages in front of virtual bullets:
<p>
(a) It takes less code to program a pattern matcher than a virtual bullets targeting system, so it makes it the best targeting solution for microbots.
(b) It is really powerful (more than virtual bullets) against bots that have repetitive behaviour, even if it is complex.
<p>
Of course, it has some disadvantages also:
<p>
(a) It needs lots of information about enemy movements, so it is more suitable for 1vs1 than for meele. 
(b) Virtual bullets work better against bots with "almost random" behaviour.
<p>
Some bots of mine using pattern matching:
<p>
- Aspid and <a href="robowiki@MicroAspid" class=wikipagelink>MicroAspid</a> use a pattern matcher that uses linear velocity and angular velocity as data series. 
- Mamba (you can only download it as a team: <a href="robowiki@MambaTeam" class=wikipagelink>MambaTeam</a>) is using an hybrid pattern matcher/virtual bullets system (need some tuning...) and uses VB or PM depending on which system has a higher success rate (ie. it is using VB to see if PM is working). The need for continuos data series is overcomed by a clever use of radars and information exchange (remember, they are a team).
<p>
-- Albert
<p>
One disadvantage of most patternmatchers is it considerable slows down your battles. Some bots cause a very low framerate, even with the <a href="robowiki@Robocode" class=wikipagelink>Robocode</a> window minimized. (Fermat 2.0 and NeonTetra<a href="robowiki@action=edit&id=NeonTetra" class=wikipageedit>?</a> for example slow the battles down to 30-40 frames per second on my computer).
The problem is, that a lot of bots does it's patternmatching every single frame.
One way to speed things up is to do the patternmatching only, when you are about to fire:
<pre>
if ((getGunHeat()/getGunCoolingRate()) &lt; 4)
{
	...
	...
	(patternmatching stuff)
	...
	...
}
</pre>
<p>
That magic "4" more or less just came out of thin air, I'm afraid. ;-)
If you keep your gun aimed directly at your opponent when you're not firing, you'll usually need only one or two ticks to aim your gun at your predicted spot when you do want to fire... three just to be sure, so that's why I use
if (.... &lt; 4).
The <pre>(getGunHeat()/getGunCoolingRate() &lt; 4)</pre>  instead of just <pre>(getGunHeat() &lt; .4)</pre> is because the coolingrate of the gun can be set in the options menu to a different value.
<p>
-- <a href="robowiki@Dummy" class=wikipagelink>Dummy</a>
<p>
What do you people do to speed up the process of searching for a pattern?  I think <a href="robowiki@Rozu" class=wikipagelink>Rozu</a> and <a href="robowiki@Vic_Stewart" class=wikipagelink>Vic Stewart</a> both said they match a somewhat large window without a major performance problem.  What's your system?  -- <a href="robowiki@Kawigi" class=wikipagelink>Kawigi</a>
<p>
With <a href="robowiki@LeachPMC" class=wikipagelink>LeachPMC</a> I use a "binary" search approach. It matches 350+ length patterns on average against <a href="robowiki@PatternBot" class=wikipagelink>PatternBot</a> and doesn't care if I ask it to try 1000 character searches or 10 characters. If it fails matching on 1000 it tries 500, then 250 ... and if it gets a match on 500 it tries 750.. you get the picture I think. =) -- <a href="robowiki@PEZ" class=wikipagelink>PEZ</a>
<p>
What do you do to look for the pattern of length 1000 or 500 or whatever?  Are you using a symbolic pattern-matcher still? -- <a href="robowiki@Kawigi" class=wikipagelink>Kawigi</a>
<p>
Yes, I build a "char" from the heading delta and velocity measures and use that for matching with the String.indexOf() functions. <a href="robowiki@LeachPMC" class=wikipagelink>LeachPMC</a> 1.2 limits itself to try for 600 chars matches. But that's not for matching performance, it's because I observed that when I got matches of 1100+ chars I was more vulnerable for when <a href="robowiki@PatternBot" class=wikipagelink>PatternBot</a> leaves it pattern and starts over. I think <a href="robowiki@Vic" class=wikipagelink>Vic</a> might have underestimated how long those rounds would be when both bots get near 100% hit rate. =) Try <a href="robowiki@Frankie" class=wikipagelink>Frankie</a> and you'll see that it's a fast bot even though it tries for very long search vectors. I will probably shorten that max length because real bots don't show 1100+ strings of exact repeating movement anyway. -- <a href="robowiki@PEZ" class=wikipagelink>PEZ</a>
<p>
<a href="robowiki@Ender" class=wikipagelink>Ender</a> / <a href="robowiki@EnderPMC" class=wikipagelink>EnderPMC</a> works exactly the same as PEZ described here. I get performance problems when the patternbuffer grows beyond 15k. I also improved performance by checking each tick if the last found pattern is still valid. -- <a href="robowiki@Vic" class=wikipagelink>Vic</a>
<p>
Of course I also use <a href="robowiki@Dummy" class=wikipagelink>Dummy</a>'s suggestion about only running the matcher when the gun is cool enough for it to be worth the bother. Though I use the magic number 3 instead of 4. -- <a href="robowiki@PEZ" class=wikipagelink>PEZ</a>
<p>
I use the magic number '1' and keep the gun directly at the opponent on other turns so I won't need more than that (at least in <a href="robowiki@TeancumPMC" class=wikipagelink>TeancumPMC</a>).  Does anyone do a closest-match search that runs reasonably quickly (like with doubles)? -- <a href="robowiki@Kawigi" class=wikipagelink>Kawigi</a>
<p>
I'm trying to code a patern matching gun for my bot for the first time. I know almost zero physics though. At first, I am going to use arraylist instead of string buffer w/ chars/strings and java's own mathing thing so that i can fully understand how it works. In the arraylist, do i want to store their heading to mine(absoluteheading) and their velocity? Or do i store their heading as a set of coordinates? And when i go back to analize it, how exactly does that work? How do I actuall match that? Does adding of vectors come up, because i don't really know what that is. Someone explain all this junk to me please. - Andrew
<p>
The simplest type, I believe, is storing the enemy's velocity and heading change (currentheading-lastheading). Then you match their current velocity and heading change, or say, the last 7, and search for matching patterns. Then you figure out how many ticks until your bullet would hit them and predict their position based on the matches you found. No vectors. There are a few good examples of pattern matchers. I remember Iapetus by tobe being really easy to grasp. -- <a href="robowiki@Alcatraz" class=wikipagelink>Alcatraz</a>
<p>
EDIT CONFLICT : * What I did when I wrote my PM gun was to store the *enemies* velocity and change heading on a given tick. The I would play back the last seven ticks worth of change and look for that pattern in the memory buffer. When you find a match, you play those heading changes and velocities back, projecting from the current location and heading, iteratively until a bullet could travel far enough from your current position to impact with the projected position. Take the absolute bearing to that position and shoot there. Some things to consider are how often to check your buffer (I only checked for the 4 ticks before I was absolutely going to shoot), how big should you let your buffer get, how do you handle not finding a match, how do you deal with the possibility of more than one match possibility, will/should you use a variable length pattern to match on. I am sure there are tons of other options as well (<a href="robowiki@ABC" class=wikipagelink>ABC</a>,<a href="robowiki@Albert" class=wikipagelink>Albert</a>,<a href="robowiki@Axe" class=wikipagelink>Axe</a>?). I strongly suggest you look to do it symbolically first unless you are prepared to some how compare multiple array positions across mulitlpe arrays (If you only match on speed and heading change you will need to compare a 2 dimmensional array of the latest movement with the two dimmensional array of your "movie history" to look for a match. More aspects to match on means more dimmensions to compare). String matching is much easier and I think a bit easier to understand. A thought that occurs to me is that you might be able to use matirx math to compare the multi-dimmensional arrays. It might even be a fast way to do it too. -- <a href="robowiki@Jim" class=wikipagelink>jim</a>
<p>
If he doesn't know anything about vectors he doesn't know anything about matrices, they're the same thing. Anyway, yes, that was all correct, just don't get too caught up in the details of this. The basic idea of a pattern matcher is that you record some part of your enemy's movement (heading, velocity, acceleration, lateral velocity, advancing velocity, etc) all the time. Then when you want to fire you look at the last few moves and find the last time it did something like those few moves. Next you go to one move after what you've already seen and start moving them according to what they did last time. Once you've moved them far enough that a bullet could get from you to their new position you figure out where you've moved them to and shoot at it. The typical example is to store your enemy's change in heading and their velocity. This lets you identify any particular move with something like "they turned left two degrees and went forward 8 units", which is a complete description of the motion. When you want to fire you look at how your opponent has been moving lately (last 7 moves was mogbot's choice, and has been emulated alot) and search through all the movements you've seen until you find ones which look the same. There are lots of options in how to determine "look the same".
<p>
Symbolically you store a string where each character is just <tt>(char)e.getVelocity()</tt> and <tt>(char)(e.getHeading - lastHeading)</tt>. Because char is only a whole number value (basically just the character's ASCII value) you're rounding all your results to whole numbers, and keeping only approximate values. This means that you can look for the last time an identical string occured and be almost guaranteed a match (only a few strings are possible when you're looking at the numbers this roughly). Once this is done you go to the end of the pattern you matched and go forward one. This is the next move you expect your enemy to make, but haven't seen yet. Using something like <tt>(int)stringRecordingOfVelocity<a href="robowiki@action=edit&id=RecordingOfVelocity" class=wikipageedit>?</a>.charAt(++endOfMatch<a href="robowiki@action=edit&id=OfMatch" class=wikipageedit>?</a>);</tt> and <tt>(int)stringRecordingOfVelocity<a href="robowiki@action=edit&id=RecordingOfVelocity" class=wikipageedit>?</a>.charAt(endOfMatch<a href="robowiki@action=edit&id=OfMatch" class=wikipageedit>?</a>);</tt> you can grab the next movement's heading change and velocity. If you take their current heading and add the heading change you've got the direction of the next movement, then you need to figure out where that is. The easiest way to proceed is grab their current {x, y} and then simple figure out the change in x and y from this movement. This is exactly the same as working out their coordinates, in Robocode you multiple sin(heading) by the amount they move (velocity) resulting in something like <tt>deltaX = Math.sin(e.get<a href="robowiki@HeadingRadians" class=wikipagelink>HeadingRadians</a> + Math.toRadians(nextHeadingChange<a href="robowiki@action=edit&id=HeadingChange" class=wikipageedit>?</a>)) * nextVelocity;</tt> and the same but with cos(heading) for y. In the real world you'd use sin and cos in the opposite order, just so you know. Adding deltaX and deltaY to their current x and y gives you their x and y after that move. Using 20 - 3 * bulletVelocity you can determine how far the bullet can travel during that move. Check the distance of this next {x, y} and see if the bullet can travel more than that distance. On the first move this will probably be false. Next you go back to where you were when you first matched the movement and went forward one. Starting there, go forward one more. Move them forward from the new {x, y} you calculated to a still newer {x, y} and calculate if the bullet could travel that far in two ticks, and then do the same for three ticks and so forth until your bullet hits them. Aim at that point and fire. Incidentally, the adding of the deltaX and deltaY is vector addition, that's all there is to it, don't get intimidated by a term.
<p>
Using non-symbolic methods this is a bit trickier. If you're using something like doubles you have really exact numbers on how they moved, if you go back and look for the last time these exact numbers occured you're often going to find that they didn't occur before. Something very similar that represents the same move may have, however. To do this you look in the history and find the move with the least error. To calculate error you do something like <tt>(observedHeadingChange<a href="robowiki@action=edit&id=HeadingChange" class=wikipageedit>?</a> - recordedHeadingChange<a href="robowiki@action=edit&id=HeadingChange" class=wikipageedit>?</a>)/maximumPossibleHeadingChange<a href="robowiki@action=edit&id=PossibleHeadingChange" class=wikipageedit>?</a></tt>. For a few reasons you usually want to square this number (obviously making it positive is a big issue, and any number squared is positive). Then do the same calculation for velocity and add the two numbers. This is one way to find your error for this move. You add up the error for every move in the sequence and choose the sequence with the least error, then basically proceed as above moving them forward until you could shoot them.
<p>
This is far from an exhaustive treatise, all I've outlined here is the basic idea of look at last time they did something and then assuming the next thing they do is the same. I also figure I've made at least one error, so feel free to correct and add to it. Remember also that heading change and velocity can be any values that uniquely identify the movement, so feel free to be creative.
<p>
-- <a href="robowiki@Kuuran" class=wikipagelink>Kuuran</a>
<p>
Thanks Kuuran and everyone else-andrew (old post deleted)
<p>
Thanks Kuuran, I think I got something out of that too.  I'm working on a symbolic absolute pattern matcher (my friend submitted a relative matcher :o ).  What andrew was referring to was the mathematical vector that I always seem to be talking about (we're friends).  I don't use math vectors in shooting, I use them only in movement.  Oh yea, andrew, a vector is a representation of direction and magnitude. --Scoob
<p>
You might get some help by checking the <a href="robowiki@LeachPMC/Code" class=wikipagelink>LeachPMC/Code</a> page. It's the gun from one of the highest ranking challengers in the <a href="robowiki@PatternMatcherChallenge" class=wikipagelink>PatternMatcherChallenge</a>. Be aware that the code holds some special tricks that might fit only in the PMC. There's a discussion at the bottom of the page about it. -- <a href="robowiki@PEZ" class=wikipagelink>PEZ</a>
<p>
<a href="robowiki@Andrew" class=wikipagelink>Andrew</a>, i recommend u also two pages: <a href="robowiki@TronsGun" class=wikipagelink>TronsGun</a>(it's the gun of Shadow, the #1 bot) &amp; <a href="robowiki@Musashi" class=wikipagelink>Musashi</a>(My bot). There you can find info about PM and some interesting ideas too. <a href="robowiki@Musashi" class=wikipagelink>Musashi</a>'s code is open-source, feel free to study it if u want (although it's a little bit messy).<br>
One important thing when developping a PM gun, is the bots that u use to test it. I recommend <a href="robowiki@Infinity" class=wikipagelink>Infinity</a>, if you can hit it 90%+, your PM gun is working. Btw, welcome! -- <a href="robowiki@Axe" class=wikipagelink>Axe</a> 
<p>
Very good point, also grab a copy of <a href="robowiki@PatternBot" class=wikipagelink>PatternBot</a>. If you ever miss it you aren't pattern matching. Ditto for <a href="robowiki@SpinBot" class=wikipagelink>SpinBot</a>. -- <a href="robowiki@Kuuran" class=wikipagelink>Kuuran</a>
<p>
<p>
//////////////////////
int i=0;
<PRE >
		while (true){
</PRE>
<p>
<PRE >
			projectedheading=(int)lastfourhundredheading.charAt(i+posistionheading);
			projectedvelocity= (int)lastfourhundredvelocity.charAt(i+posistionvelocity);
			delta_x=Math.sin(e.get<a href="robowiki@HeadingRadians" class=wikipagelink>HeadingRadians</a>() + Math.toRadians(projectedheading)) * projectedvelocity;
			delta_y=Math.cos(e.get<a href="robowiki@HeadingRadians" class=wikipagelink>HeadingRadians</a>() + Math.toRadians(projectedheading)) * projectedvelocity;
			double distance=Math.sqrt( Math.pow((e_x+delta_x)-x,2)+Math.pow((e_y+delta_y)-y,2)) ;
			if (20-3*(400/e.getDistance())&gt;distance){
				angle = Math.atan((double)e_y+delta_y/(double)e_x+delta_x);
				break;
			}
</PRE>
////////////////////////// Whats wrong with this? I get continuous out of bounds errors. - andrew
<PRE >
			i++;
		}
</PRE>
<p>
You have a i++ into the an infinite loop "while(true)" so it will grow until the index is higher than the last position of your string ... -- <a href="robowiki@Albert" class=wikipagelink>Albert</a>
<p>
It's probably the exit condition that doesn't guarantee that "i" doesn't grow above the boundaries. Try using a for loop instead:
<pre>
for (int i = 0; i &lt; leastfourhundreadheading.length() - positionheading; i++) {
   projectedheading=(int)lastfourhundredheading.charAt(i+posistionheading);
   projectedvelocity= (int)lastfourhundredvelocity.charAt(i+posistionvelocity);
   delta_x=Math.sin(e.getHeadingRadians() + Math.toRadians(projectedheading)) * projectedvelocity;
   delta_y=Math.cos(e.getHeadingRadians() + Math.toRadians(projectedheading)) * projectedvelocity;
   double distance=Math.sqrt( Math.pow((e_x+delta_x)-x,2)+Math.pow((e_y+delta_y)-y,2));
   if (20 - 3 * (400 / e.getDistance()) &gt; distance) {
      break;
   }
}
angle = Math.atan((double)e_y+delta_y/(double)e_x+delta_x);
</pre>
I'm not sure about the length() method. But a method of checking a String's name exists and it seems a reasonable name. =)
<p>
-- <a href="robowiki@PEZ" class=wikipagelink>PEZ</a>
<p>
<p>
It's a string buffer so length() is the correct function. - andrew
i think the problem is in by bogus calculations. trying to fix now
<p>
<p>
<hr noshade class=wikiline size=1>
<p>
Hi, I'm new-ish to Robocode, and I've been trying to write a pattern-matching gun recently - my bot already has a basic <a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a> gun, as well as a circular targeting gun in a virtual guns array. I can't seem to get the pattern-matching gun to work properly, though - it fires in the general direction of the other bot (This is one-on-one), and gets about a 20% hitrate on Spinbot at the most. Can anyone see what's wrong with this?
<p>
<pre>
private class PatternVector {
		private double hchange=0;
		private double length=0;
		
		public PatternVector(double h, double l) {
			hchange=h;
			length=l;
		}
		
		public double compare(PatternVector p) {
			double hd=hchange-p.hchange;
			double ld=length-p.length;
			return hd*hd+ld*ld;
		}
		
		public double calcXPos(double x, double h) {return x+Math.sin(calcH(h))*length;}
		public double calcYPos(double y, double h) {return y+Math.cos(calcH(h))*length;}
		public double calcH(double h) {return h+hchange;}
	}
	
	private class PatternMatchingGun extends Gun {
		private ArrayList history=new ArrayList();
		private Enemy lastdata;
		
		private int findBestPattern() {
			int bestindex=history.size();
			double bestscore=PATTERN_THRESHOLD;
			double curscore=0;
			PatternVector current;
			for(int a=0;a&lt;history.size()-PATTERN_RECENTHISTORY_LENGTH;a++) {
				curscore=0;
				for(int b=history.size()-PATTERN_RECENTHISTORY_LENGTH;b&lt;history.size();b++) {
					current=(PatternVector) history.get(a);
					curscore+=current.compare((PatternVector) history.get(b));
				}
				if(curscore&lt;bestscore) {bestindex=a+PATTERN_RECENTHISTORY_LENGTH+1; bestscore=curscore;}
			}
			return (int) bestindex;
		}
		
		private void addData(Enemy e) {
			if(lastdata==null) {lastdata=e;}
			history.add(new PatternVector(normalRelativeAngle(lastdata.lastheading-e.lastheading),e.velocity));
			if(history.size()&gt;PATTERN_HISTORY_LENGTH) {history.remove(0);}
			lastdata=new Enemy(e.name,e.lastenergy,e.lastheading,e.lastscan,e.bearing,0,v);
		}
		
		private Point2D.Double calcEnemyPos(double when, Enemy e, int startofpattern) {
			double diff=when-t;
			double ix=e.ex;
			double iy=e.ey;
			double head=e.lastheading;
			PatternVector p;
			for(int a=startofpattern;a&lt;=(diff+startofpattern);a++) {
				if(history.size()&gt;a) {
					p=(PatternVector) history.get(a);
					ix=p.calcXPos(ix,head);
					iy=p.calcYPos(iy,head);
					head=p.calcH(head);
				}
			}
			return new Point2D.Double(ix,iy);
		}
		
		public void targeting(Enemy e, boolean virt) {	
			double time;
			double nexttime;
		
			Point2D.Double p = new Point2D.Double(e.ex, e.ey);

			double px=x+Math.sin(h)*v;
			double py=y+Math.cos(h)*v;
			
			int pstart=findBestPattern();
			
			for (int i = 0; i &lt; iterations; i++) {
				nexttime = Math.round((dist(px,py,p.x,p.y)/(20-(3*bulletpower))));
				time = t + nexttime;
    		  	 	p = pgun.calcEnemyPos(time,e,pstart); 
				pstart+=nexttime;
			}
		
			double gunoffset = getGunHeadingRadians() - (Math.PI/2 - Math.atan2(p.y - py,p.x -  px));
			gunoffset=normalRelativeAngle(gunoffset);
		
			if(!virt) {
				setTurnGunLeftRadians(gunoffset);
				if(getGunHeat()==0) {log("Firing Pattern-Matching gun"); setFire(bulletpower); bulletsfired++;}
			}
			else {vbullets.add(new VBullet(getGunHeadingRadians()-gunoffset,x,y,t,bulletpower));}
		}
	}
</pre>
<p>
As you can see, it's a fairly basic non-symbolic pattern matcher. The 'virt' boolean variable is used for firing virtual bullets to find the best gun to use in various circumstances, h is my heading in radians, t is the time, x and y are my x and y loc, v is my velocity. I call addData() whenever I get a new scan of the other bot. I haven't been able to figure out why it's weirding up, but it certainly isn't pattern-matching properly. Any ideas?--<a href="robowiki@Jp" class=wikipagelink>Jp</a>
<p>
Hey, Welcome! It is very important for this type of PM gun to get a new scan on every tick. The first thing i'd check is that you aren't missing any scans. If I have time later i'll take a closer look at the code. --<a href="robowiki@Wcsv" class=wikipagelink>wcsv</a>
<p>
In calcEnemyPos<a href="robowiki@action=edit&id=EnemyPos" class=wikipageedit>?</a>(), both your x and y coordinate are calling calcXPos(). I'm assuming you want that to be calcYPos() for your y coord. Hope that helps. --<a href="robowiki@Corbos" class=wikipagelink>Corbos</a>
<p>
Welcome! why don't you make a page for yourself when you get a chance? In the meantime, if what <a href="robowiki@Corbos" class=wikipagelink>Corbos</a> suggested didn't solve it, could you post the entire bot? Or at least enough of it that I can get it to compile and run? I can't debug stuff in my head very well. =) See you in the rumble! --<a href="robowiki@David_Alves" class=wikipagelink>David Alves</a>
<p>
I'm so embarrassed that I didn't pick that one up. It hasn't massively improved it's accuracy, though, so I've got some other bugs somewhere. I'll create a page for myself and throw the bot up there - it's fairly ugly, though, so be warned. :) --<a href="robowiki@Jp" class=wikipagelink>Jp</a>
<p>
Another possible issue, see ordered comments below:
<pre>
private class PatternVector {
	public double calcXPos(double x, double h) {
		return x+Math.sin(calcH(h))*length;	&lt;!---#3 calcXPos uses calcH which adds the heading delta again.
							This second addition of the delta will really mess things up if
							you're "playing the pattern forward" for more than a tick or two.
	}
	public double calcYPos(double y, double h) {return y+Math.cos(calcH(h))*length;}
	public double calcH(double h) {return h+hchange;}
}
	
private class PatternMatchingGun extends Gun {
	private Point2D.Double calcEnemyPos(double when, Enemy e, int startofpattern) {
		...
		for(int a=startofpattern;a&lt;=(diff+startofpattern);a++) {
			if(history.size()&gt;a) {
				p=(PatternVector) history.get(a);
				ix=p.calcXPos(ix,head);	&lt;!---#2 Use calcXPos() to project ix
				iy=p.calcYPos(iy,head);
				head=p.calcH(head);	&lt;---#1 Add the vector's heading delta to the current heading.
			}
		}
		return new Point2D.Double(ix,iy);
	}
}
</pre>
Hope that helps. --<a href="robowiki@Corbos" class=wikipagelink>Corbos</a>
<p>
On second thought, i guess your order is actually correct - add it for ix, then add it to head after you project ix. No more debugging at a glance for me. --<a href="robowiki@Corbos" class=wikipagelink>Corbos</a>
<p>
Aha! After altering the calcEnemyPos<a href="robowiki@action=edit&id=EnemyPos" class=wikipageedit>?</a>() function so that it actually draws where I think the other bot will end up, I discovered that Spinbot's guesstimated trajectory was curving <i>the wrong way</i>. I was adding the heading change where I should have been subtracting it. Now that that's fixed, it gets a much better hitrate. It's still not massively good, but it's actually pattern matching, I believe. --<a href="robowiki@Jp" class=wikipagelink>Jp</a>
<p>
I'm relatively new to robocode (since August). Can anyone find out what's wrong with this gun???
<pre>
import robocode.*;
import java.awt.Color;


public class Knowledge extends AdvancedRobot
{
	static int n;
	static String headDelta = new String();
	static String velocity = new String();
	int lastHeading=0;
	int direction=1;
	int everyTick=20;

	/**
	 * run: Knowledge's default behavior
	 */
	public void run() {
		setTurnRadarRightRadians(Double.POSITIVE_INFINITY);
		// After trying out your robot, try uncommenting the import at the top,
		// and the next line:
		setColors(Color.WHITE,Color.BLACK,new Color(0,255,0));
		
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		setAdjustRadarForRobotTurn(true);
		doNothing();
	}


	
	public void onScannedRobot(ScannedRobotEvent e) {
		
		headDelta += (char)(e.getHeadingRadians()-lastHeading);
		velocity += (char)(e.getVelocity());
		n++;
		if(n&gt;100){
			String lastHeadDelta=headDelta.substring(n-8,n-1);
			String lastVelocity=velocity.substring(n-8,n-1);
			int lastSimilarHead=headDelta.indexOf(lastHeadDelta,25)+7;
			int lastSimilarVelocity=velocity.indexOf(lastVelocity,25)+7;
			
			double enemyBearing = getHeading() + e.getBearing();
			double enemyX = getX() + e.getDistance() * Math.sin(Math.toRadians(enemyBearing));
			double enemyY = getY() + e.getDistance() * Math.cos(Math.toRadians(enemyBearing));
			double bulletDistance=0;
			double time=0;
			double firePower=0;
			
			while(true){
				time++;
				double deltaX=Math.sin(e.getHeadingRadians() - ((int)(headDelta.charAt(lastSimilarHead)))) * (int)(velocity.charAt(lastSimilarVelocity));
				double deltaY=Math.cos(e.getHeadingRadians() - ((int)(headDelta.charAt(lastSimilarHead)))) * (int)(velocity.charAt(lastSimilarVelocity));
				enemyX+=deltaX;
				enemyY+=deltaY;

				if(distance(enemyX,enemyY,getX(),getY())&lt;bulletDistance){
					double vel=distance(enemyX,enemyY,getX(),getY())/time;
					firePower=(20-vel)/3;
					double dx = enemyX - getX();
					double dy = enemyY - getY();
					double theta = Math.atan2(dx, dy);		
					turnGunRightRadians(normalRelativeAngle(theta - getGunHeading()));			
					break;
				}else{
					bulletDistance+=11;
					lastSimilarHead++;
					lastSimilarVelocity++;
				}
			}
			fire(firePower);
		}
		setTurnRadarLeftRadians(getRadarTurnRemainingRadians());
	}


	public double normalRelativeAngle(double angle) {
		//taken from OddBot
		return ((angle + 15.7079633) % 6.2831853) - Math.PI;
	}
	
	public double distance( double x1,double y1, double x2,double y2 ) {
                double xo = x2-x1;
                double yo = y2-y1;
                double h = Math.sqrt( xo*xo + yo*yo );
                return h;
        }
}
</pre>
I keep getting a StringIndexOutOfBoundsException<a href="robowiki@action=edit&id=StringIndexOutOfBoundsException" class=wikipageedit>?</a>. Why? --Starrynte
<p>
I think it is because you don't check if lastSimilarHead<a href="robowiki@action=edit&id=SimilarHead" class=wikipageedit>?</a> is greater than the length of headDelta (and velocity). You can check for it with the while condition so it is something like this:
<pre>while(lastSimilarHead &lt; headDelta.length){ ... }</pre>
On a side note, I would recommend storing getX(), getY(), and getGunHeading<a href="robowiki@action=edit&id=GunHeading" class=wikipageedit>?</a>() to myX, myY, and myGunHeading<a href="robowiki@action=edit&id=GunHeading" class=wikipageedit>?</a> because <a href="robowiki@RoboCode" class=wikipagelink>RoboCode</a> does limit the number of calls to the get...() methods. Good luck with your robot! -- <a href="robowiki@Kinsen" class=wikipagelink>Kinsen</a>
<p>
<p>
Has anyone ever tried to do PM with the change in gun heading (when you are aiming)??? --Starrynte
<p>
Do you mean like the change in absolute bearing between you and the enemy? I've never done one myself, but I think that's what an "angular pattern matcher" is. <a href="robowiki@Teancum" class=wikipagelink>Teancum</a> is the only page where I can find that phrase on the wiki. If that's not what you mean, could you clarify a little? -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
Yeah, the <a href="robowiki@NanoBot" class=wikipagelink>NanoBot</a> PatternMatchers<a href="robowiki@action=edit&id=PatternMatchers" class=wikipageedit>?</a> do what you're describing. For example, <a href="robowiki@NanoLauLectrik" class=wikipagelink>NanoLauLectrik</a>. --<a href="robowiki@David_Alves" class=wikipagelink>David Alves</a>
<p>
The Nano pattern matchers do it on tangential velocity, not gun turn.  The problem with gun turn pattern matching is that it depends almost entirely on distance, so it would take a very long time to build up a useful history. --<a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
If you keep your gun aimed directly at them, they should amount to the same thing, I thought; if you're not, then matching on gun turn seems pretty useless to me. Then again, I've never made one, so I could be wrong... -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
I just discovered two errors in the code above. First, I was subtracting getGunHeading<a href="robowiki@action=edit&id=GunHeading" class=wikipageedit>?</a>() from theta instead of getGunHeadingRadians<a href="robowiki@action=edit&id=GunHeadingRadians" class=wikipageedit>?</a>(). Also, i wasn't setting lastHeading to e.get<a href="robowiki@HeadingRadians" class=wikipagelink>HeadingRadians</a>(). It probably won't help the StringIndexOutOfBoundsException<a href="robowiki@action=edit&id=StringIndexOutOfBoundsException" class=wikipageedit>?</a> though... --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
What's <a href="robowiki@TangentialVelocity" class=wikipagelink>TangentialVelocity</a>? --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
Oops, I think I posted up there with out signing it.  Fixed.  Voidious: When we're talking about pattern matching on gun turn, I assume that would be "gun offset from pointing directly at him right now."  But either way, the radians you turn your gun is vastly different depending on whether the enemy is 50 "pixels" away or 500, even if his movement is the same.  Therefore, in a pattern matcher, you would have to build up data about him at almost every possible distance before matching based on gun turn would become very useful.  SO - the nano pattern matchers match based on <a href="robowiki@TangentialVelocity" class=wikipagelink>TangentialVelocity</a>, since that is independant from distance (see the new page for the way I'm using that term).  There - maybe that was a more complete thought.  --<a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
<a href="robowiki@LateralVelocity" class=wikipagelink>LateralVelocity</a> is the more common term around here for <a href="robowiki@TangentialVelocity" class=wikipagelink>TangentialVelocity</a>.  The nano pattern-matchers (primarily) pattern match on that.  I think some version of <a href="robowiki@Teancum" class=wikipagelink>Teancum</a> or <a href="robowiki@FloodMini" class=wikipagelink>FloodMini</a> attempted to pattern match on wave results, but I don't know if I ever released a version that did that.  <a href="robowiki@Teancum" class=wikipagelink>Teancum</a> pattern-matches on <a href="robowiki@LateralVelocity" class=wikipagelink>LateralVelocity</a> and <a href="robowiki@AdvancingVelocity" class=wikipagelink>AdvancingVelocity</a>. -- <a href="robowiki@Kawigi" class=wikipagelink>Kawigi</a>
<p>
My new PM gun can hit <a href="robowiki@MyFirstRobot" class=wikipagelink>MyFirstRobot</a> pretty well and <a href="robowiki@SpinBot" class=wikipagelink>SpinBot</a> pretty well, but it can't hit Crazy at all! Does anyone know why? (code posted at <a href="robowiki@Starrynte/Knowledge" class=wikipagelink>Starrynte/Knowledge</a>) --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
Actually, correct that. The "why" is probably HOT can hit <a href="robowiki@MyFirstRobot" class=wikipagelink>MyFirstRobot</a> and <a href="robowiki@SpinBot" class=wikipagelink>SpinBot</a> pretty well but can't hit Crazy that well. Now my question is, does anyone know how to fix? (I'm not sure about the 'why' though) --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
I have a vague idea that the why is because i am using radians, which are *very* small, and will almost always be cast to 0 or 1. --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
Changing to degrees fixes it, kind of. It still can't really hit Crazy or <a href="robowiki@PatternBot" class=wikipagelink>PatternBot</a>. --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
Just out of curiousity, has anyone tried to do PM with segmentation? --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
I have tried it a little bit - basically, I tried to match some segmentation data at fire time (end of the pattern) in addition to looking for a pattern of a certain length. The resulting gun was decent, but I abandoned it. It was <a href="robowiki@Shaakious" class=wikipagelink>Shaakious</a> that had that gun, but it's currently retired / not being worked on. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<p>
<a href="robowiki@SeaSerpent" class=wikipagelink>SeaSerpent</a>s PM gun segments its data. Every tick, it adds the latest index of the pattern to a segmented list. Then when it shoots, it only matches on indexes within the current list. Because the actual matching includes things like velocity and acceleration, it only segments on distance and wall proximity. Besides making it more accurate, segmentation also makes the gun faster because it only looks at bits of the pattern at a time. -- <a href="robowiki@Kev" class=wikipagelink>Kev</a>
<p>
I think it has something to do with casting the char to an int, then the int to a double (or it could be the other way around, casting the double to an int, then the int to a char) because I set it to print the velocity that was recorded and it prints out stuff like<br>
<pre>
8.0
8.0
8.0
8.0
6.0
4.0
2.0
0.0
65535.0
65534.0
65533.0
65532.0
</pre>
against <a href="robowiki@PatternBot" class=wikipagelink>PatternBot</a> --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
That's the reason I (and many more) add 8 or MaxVelocity<a href="robowiki@action=edit&id=MaxVelocity" class=wikipageedit>?</a> to the char with my not-so-high-ranked (127) patternmatcher. Same goes for deltaheading or any other patternvariable by the way. - <a href="robowiki@GrubbmGait" class=wikipagelink>GrubbmGait</a>
<p>
Oh - you just need to cast the char to a short (or byte), then a double.  Otherwise the ones that should be negative numbers turn out like that.  If you know about the 2's compliment binary format, casting it to a short, then a double effectively does the necessary sign-extention.  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
Ok thanx...It still doesn't really hit <a href="robowiki@MyFirstRobot" class=wikipagelink>MyFirstRobot</a> --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
Okay, its long overdue, but I made my first pattern matcher from scratch that actually works. Hehe, all my other attempts (and the one by my sister), failed, generally by disinterest. But the thought of hitting Spinbot and Walls perfectly everytime, spurred me on to actually make one. --<a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
<p>
Welcome!  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
And no, it wasn't <a href="robowiki@SingleTick" class=wikipagelink>SingleTick</a> (but I made one of those too) --<a href="robowiki@Chase-san" class=wikipagelink>Chase-san</a>
<p>
That's ok, I leave room in my affections for all PM styles ;).  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
<hr noshade class=wikiline size=1>
<p>
Alright folks, this is a call to push the limits of pattern matching.  For anyone who loves pattern matching, who is curious to see how well it can do, or is just looking for a new robocoding challenge, let's put our heads together &amp; see where we can go with this.  I've moved away from the <a href="robowiki@PatternMatching/SingleTick" class=wikipagelink>/SingleTick</a> style for a while, and this more traditional method has a lot more potential then we've squeezed out of it so far.  Take a look at <a href="robowiki@TargetingChallenge2K7/Results" class=wikipagelink>TargetingChallenge2K7/Results</a>.  I've posted 2 scores, one for straight-up pattern matching and one with multiple choice.  Both have a couple features: they treat clockwise &amp; couter-clockwise movements the same, and they aim at the longest match(es) <em>that don't place the opponent out-of-bounds</em>.  You can see that multiple choice works better for non-adaptive movements, and straight-up style for wave surfers.  These could easily be combined in a VG array to push pattern mathcing's score just below the big guns in the challenge, and I bet we could get it into that group if we start playing with segmentation.  <a href="robowiki@Kev" class=wikipagelink>Kev</a> is already an expert at this (see <a href="robowiki@SeaSerpent" class=wikipagelink>SeaSerpent</a>).  I'll post a link on my homepage to source for the bot I used to get those scores, let's see what we can do. --<a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<p>
<UL >
<li> Seems to me you will start to blur the lines between <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> and <a href="robowiki@VisitCountStats" class=wikipagelink>VisitCountStats</a>, especially with talking about segmentation, or with <a href="robowiki@DynamicClustering" class=wikipagelink>DynamicClustering</a> if you just use attributes without segmenting. (<a href="robowiki@Shaakious" class=wikipagelink>Shaakious</a> was a super <a href="robowiki@SlowBot" class=wikipagelink>SlowBot</a>, but I tried to use segments with that - search for a match with also matching segments, or matching without it if there wasn't one.) You could even say that most top <a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a> / <a href="robowiki@VisitCountStats" class=wikipagelink>VisitCountStats</a> already blur the lines: attributes like "time since velocity change" (one of the most powerful) or "distance last eight ticks" (less powerful, but <a href="robowiki@Dookious" class=wikipagelink>Dookious</a> and <a href="robowiki@Shadow" class=wikipagelink>Shadow</a> use 'em) have shades of <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a>, in my opinion. Good luck, dudes. =) -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
<p>
<UL >
<li> I don't mind bluring the line.  Actually the line just needs better definition :).  Segmenting doesn't make a PM gun any less PM, it's the "play-it-forward" technique, imo.  I just think pattern matching does an lot of segmentation for you, which you have to hard-code in GF guns.  But there may still need to be some hard coded into pattern matching, like wall distance (probably my next move).  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
</UL>
<p>
<UL >
<li> Not sure I agree on that being the line - <a href="robowiki@ABC" class=wikipagelink>ABC</a> has used "play it forward" to project firing angle with guns that I wouldn't consider <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> (<a href="robowiki@TronsGun" class=wikipagelink>TronsGun</a> / <a href="robowiki@DynamicClustering" class=wikipagelink>DynamicClustering</a>). Seems to me like on one side you have some sort of stats system: look through a log of past states (<a href="robowiki@TronsGun" class=wikipagelink>TronsGun</a> / <a href="robowiki@DynamicClustering" class=wikipagelink>DynamicClustering</a>); look through tallied statistics based on past states (<a href="robowiki@VisitCountStats" class=wikipagelink>VisitCountStats</a> / "traditional" <a href="robowiki@GuessFactorTargeting" class=wikipagelink>GuessFactorTargeting</a>); or match the last X states with a log of states (<a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a>). On the angle projection side, you have: take the most popular angle (or <a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a>) among matching states (<a href="robowiki@VisitCountStats" class=wikipagelink>VisitCountStats</a> or <a href="robowiki@Ali" class=wikipagelink>Ali</a>'s log-based gun); find the angle (or <a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a>) that is somehow the "best" from the set of all matching states (<a href="robowiki@DynamicClustering" class=wikipagelink>DynamicClustering</a>, <a href="robowiki@MultipleChoice" class=wikipagelink>MultipleChoice</a>); or "play the movie forward" and shoot at the angle that hit the bot at that spot in previous situation(s). Traditional <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> is the last choice on both sides, but it seems to me like the "pattern matching" part comes in the first part (stats searching), not the second (angle projection). It's funny how often we end up in these semantic debates on this wiki - I sometimes wonder how much all these labels matter =) But I do think it's helpful to clarify ideas. E.g., "<a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a>" tends to be synonymous with <a href="robowiki@VisitCountStats" class=wikipagelink>VisitCountStats</a> when it can just as easily be used in <a href="robowiki@DynamicClustering" class=wikipagelink>DynamicClustering</a> - it's not really a stats system, just a great way of interpreting a firing angle. -- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
<UL >
<li> Then I'm forced to wonder where <a href="robowiki@Engineer" class=wikipagelink>Engineer</a> fits in with its neural network =) Maybe it's more like "maintain a data structure that points at the best angle / <a href="robowiki@GuessFactor" class=wikipagelink>GuessFactor</a> for a given state" for the "tallied statistics" description in my previous statement. Ok, done babbling for now...-- <a href="robowiki@Voidious" class=wikipagelink>Voidious</a>
</UL>
</UL>
<p>
Another thing is to look for seperate patterns in velocity and deltaheading. This made a huge difference - the difference between Decado 0.1 and Waylander 0.1, to be precise. About 6 places in the MicroRumble<a href="robowiki@action=edit&id=MicroRumble" class=wikipageedit>?</a>. Next I will try <a href="robowiki@MultipleChoice" class=wikipagelink>MultipleChoice</a> . --<a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
<UL >
<li> Ok, interesting.  I'll have to give that some more research.  I tried that with <a href="robowiki@PatternMatching/SingleTick" class=wikipagelink>/SingleTick</a> pattern matching a while back, but it didn't help there.  -- <a href="robowiki@Simonton" class=wikipagelink>Simonton</a>
<li> I take that back, it seems the reason Waylander suffered so much was that I was using too many possible values for angle-change, so it could never find a match. Now that it's fixed it outranks Decado by quite a bit. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
</UL>
<p>
<hr noshade class=wikiline size=1>
<p>
I was thinking about restarting work on my <a href="robowiki@Rednaxela/NeuralPatternMatching" class=wikipagelink>NeuralPatternMatching</a>, and had one thought about <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> in general. Usually all of the <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> I've seen seems either strictly relative, or strictly absolute. One thing I was thinking about today, is why couldn't they be combined? It shouldn't be difficult to store both relative and absolute movement in a <a href="robowiki@PatternMatcher" class=wikipagelink>PatternMatcher</a>'s memory, and use whatever type happens to get the highest score. In fact, you could have multiple different types of relative segments in the same <a href="robowiki@PatternMatcher" class=wikipagelink>PatternMatcher</a> and whichever one pulls up the strongest corrolation on a given tick could be used. I wonder, has anyone previously combined different types of <a href="robowiki@PatternMatching" class=wikipagelink>PatternMatching</a> as I describe or has it really not been done before? -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
I have FINALLY managed to create a naive symbolic PM gun that can hit pattern bots 90% of the time...:) --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<p>
Congrats! Now if only I could get my <a href="robowiki@Rednaxela/NeuralPatternMatching" class=wikipagelink>NeuralPatternMatching</a> to work that well... :) -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
<UL >
<li> Disclaimer: It can hit <a href="robowiki@PatternBot" class=wikipagelink>PatternBot</a> and Spinbot 90% of the time...which may or may not imply other pattern bots --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
</UL>
<p>
If my PM gun (a new one) "sometimes" works and "sometimes" doesn't, what can be the problem? To clarify: sometimes it finds the "match", yet sometimes it doesn't... --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<UL >
<li> Abandoning project for now...Eclipse is too frustrating for me as of now...maybe I'll continue it in a few hours --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<UL >
<li> Edit: Eclipse was frustrating because something went wrong, and now everything that was in my robots folder is gone, with no backups. (this includes the perfect PM gun above :( ) --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<li> Ok, recoded a clone of the PM gun above, now I just have to recover my new melee bot... --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
<UL >
<li> Codesize successfully shrunk down to 568 (and counting), including a simple oscillator (thank you, binary operators)...now i'll see if i can add a <a href="robowiki@StopAndGo" class=wikipagelink>StopAndGo</a> movement...or segmentation...and a name! :) --<a href="robowiki@Starrynte" class=wikipagelink>Starrynte</a>
</UL>
</UL>
</UL>
<p>
So far all of my attempt have been based on non-relative positioning (velocity/acceleration and turning rate) because that's made the most sense to me, but I have some questions about patternmatching with <a href="robowiki@LateralVelocity" class=wikipagelink>LateralVelocity</a> and <a href="robowiki@AdvancingVelocity" class=wikipagelink>AdvancingVelocity</a> like I often see used as well. In particular, because <a href="robowiki@LateralVelocity" class=wikipagelink>LateralVelocity</a> and <a href="robowiki@AdvancingVelocity" class=wikipagelink>AdvancingVelocity</a> are measured relative to your position, and generally your own gun can't know your own future movement so I can't see how a relative patternmatcher would work effectively. It seems to me that not knowing what they will be moving relative to would make the data quite invalid. Is there something I'm missing or do people just live with this inaccuracy that to me seems quite major? -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
I also questioned that - I certainly wouldn't use relative data as a method to rebuild enemy movement (codesize limited environments excluded), but *matching* on the data is perfectly valid, and might pick up patterns that absolute matchers might miss due to the other bot reacting to your movement. If you want to see a quick (and 100% accurate) way to rebuild enemy data, take a look at <a href="robowiki@DrussGT/HelpRequests" class=wikipagelink>DrussGT/HelpRequests</a> - it's the one that <a href="robowiki@Shadow" class=wikipagelink>Shadow</a> uses. I just right now found that bug in my PlayItForward<a href="robowiki@action=edit&id=PlayItForward" class=wikipageedit>?</a> DC gun mentioned there (accidently used degrees for heading - aargh!!) so I'm releasing it to the rumble to see what happens =). <a href="robowiki@Simonton" class=wikipagelink>Simonton</a> released 2 versions of <a href="robowiki@WeeklongObsession" class=wikipagelink>WeeklongObsession</a>, one with relative, one with absolute, and they scored the same. To me this indicates that relative finds better patterns, to make up for its slight inaccuracy. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
Hmm, interesting. I'm thinking now that I may end up making the PM gun in <a href="robowiki@RougeDC" class=wikipagelink>RougeDC</a>, into something that matches on both relative and absolute patterns as well as perhaps eventually slight segmentation and rebuilds with absolute movement only... That would probably complement the normal DC/GF gun I have rather nicely... :) -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
<p>
Rebuilding lots of patterns using velocity/acceleration and deltaheading can get pretty slow! I'm not sure if you quite understand the method that <a href="robowiki@Shadow" class=wikipagelink>Shadow</a> (and currently <a href="robowiki@DrussGT" class=wikipagelink>DrussGT</a> - we'll have to see if it helps) use - instead of 'rebuilding' the movement they made last time in this new position, we project our own location to be in the same 'relative' position to the recorded co-ordinates and just see where their co-ordinates go as time progresses from that point. You check what the angle offset is from your 'relative' location, and that's what the angle offset is in this new situation as well. You can even do boundary checking on their final location by projecting from your 'actual' location at that offset from the absolute bearing, using the distance of your 'relative' location to their co-ordinates when the bullet hits them. -- <a href="robowiki@Skilgannon" class=wikipagelink>Skilgannon</a>
<p>
Yep, I do understand that, though it's slightly incompatible with my precise botwidth calculations that I'm fond of, but do halfway between that method and the slow one by using iterative integer addition based around a similar principal, in place of all the trig, which should run pretty fast too. -- <a href="robowiki@Rednaxela" class=wikipagelink>Rednaxela</a>
</div><hr class=wikilinefooter>
<div class=wikifooter><form method="post" action="robowiki" enctype="application/x-www-form-urlencoded">
<a href="robowiki@Robo_Home" class=wikipagelink>Robo Home</a> | <a href="robowiki@Changes" class=wikipagelink>Changes</a> | <a href="robowiki@action=editprefs">Preferences</a> | <a href='?action=index'>AllPages</a><br>
<a href="robowiki@action=edit&id=PatternMatching" class=wikipageedit>Edit text of this page</a> | <a href="robowiki@action=history&id=PatternMatching">View other revisions</a><br>Last edited March 22, 2009 2:31 EST by <a href="robowiki@Pakistan" title="ID 17795 from 63-230-6-83.slkc.qwest.net">Pakistan</a> <a href="robowiki@action=browse&diff=1&id=PatternMatching">(diff)</a><br>Search: <input type="text" name="search"  size="20" /><input type="hidden" name="dosearch" value="1"  /></form></div>
</body>
</html>